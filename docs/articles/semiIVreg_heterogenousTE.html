<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Estimator Performance: general heterogenous treatment effect model • semiIVreg</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Estimator Performance: general heterogenous treatment effect model">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="default" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">semiIVreg</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/semiIVreg.html">Model and Guidelines</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-more" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">More</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-more">
<li><a class="dropdown-item" href="../articles/semiIVreg_homogenousTE.html">Estimation with Homogenous Treatment Effect</a></li>
    <li><a class="dropdown-item" href="../articles/semiIVreg_heterogenousTE.html">Estimation with general Heterogenous Treatment Effect</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://twitter.com/CBruneelZupanc" aria-label="Twitter"><span class="fa fa-twitter"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/cbruneelzupanc/semiIVreg" aria-label="Github"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Estimator Performance: general heterogenous treatment effect model</h1>
                        <h4 data-toc-skip class="author"><a href="https://www.cbruneel.com/" class="external-link">Christophe Bruneel-Zupanc</a></h4>
            
            <h4 data-toc-skip class="date">Last modified:
2024-07-22</h4>
      

      <div class="d-none name"><code>semiIVreg_heterogenousTE.Rmd</code></div>
    </div>

    
    
<p>Let us compare the performance of the semi-IV estimator in a
<strong>generalized Roy model</strong> with <strong>heterogenous
treatment effects</strong>. The simulation specification comes from
<span class="citation">Bruneel-Zupanc (2024)</span>. It is close to the
counterpart standard IV simulated Roy models used in <span class="citation">James J. Heckman, Urzua, and Vytlacil (2006)</span> or
<span class="citation">James J. Heckman and Vytlacil (2007)</span>.</p>
<div class="section level2">
<h2 id="simulate-data">Simulate data<a class="anchor" aria-label="anchor" href="#simulate-data"></a>
</h2>
<p>We simulate generalized Roy models using the
<code><a href="../reference/simul_data.html">simul_data()</a></code>function. See the documentation of the function
for details about the model. Depending on the chosen parameters, we can
simulate a model with homogenous/heterogenous treatment effects, as well
as with valid IVs eventually. That’s what we will do here. In every
simulation we do not include covariates (set all their effect to 0), but
these can be easily included.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Model</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://www.cbruneel.com/" class="external-link">semiIVreg</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; KernSmooth 2.23 loaded</span></span>
<span><span class="co">#&gt; Copyright M. P. Wand 1997-2009</span></span>
<span><span class="co">#&gt; Loading required package: zoo</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Attaching package: 'zoo'</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:data.table':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     yearmon, yearqtr</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:base':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     as.Date, as.Date.numeric</span></span>
<span><span class="va">N</span> <span class="op">=</span> <span class="fl">50000</span>; <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="co"># Specification</span></span>
<span><span class="va">model_type</span> <span class="op">=</span> <span class="st">"heterogenous"</span></span>
<span><span class="va">param_error</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="co"># var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous</span></span>
<span><span class="va">param_Z</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1.5</span>, <span class="fl">1.5</span>, <span class="fl">0.9</span><span class="op">)</span> <span class="co"># meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1</span></span>
<span><span class="va">param_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="op">-</span><span class="fl">0.7</span>, <span class="fl">0.7</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ</span></span>
<span><span class="va">param_y0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3.2</span>, <span class="fl">0.8</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># intercept, effect of Wd, effect of state, effect of parent educ;</span></span>
<span><span class="va">param_y1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3.2</span><span class="op">+</span><span class="fl">0.4</span>, <span class="fl">0.5</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ;</span></span>
<span><span class="va">param_genX</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="../reference/simul_data.html">simul_data</a></span><span class="op">(</span><span class="va">N</span>, <span class="va">model_type</span>, <span class="va">param_y0</span>, <span class="va">param_y1</span>, <span class="va">param_p</span>, <span class="va">param_Z</span>, <span class="va">param_genX</span>, <span class="va">param_error</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="semi-iv-regression">semi-IV regression<a class="anchor" aria-label="anchor" href="#semi-iv-regression"></a>
</h2>
<p>Let us apply directly the <code><a href="../reference/semiivreg.html">semiivreg()</a></code>function. Compute
the MTE and MTR for a reference individuals with average value of the
semi-IVs, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>W</mi><mn>0</mn></msub><mo>,</mo><msub><mi>W</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(W_0, W_1) = (0, 0)</annotation></semantics></math>
here. Remark: the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>,</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">MTE(u, w_0, w_1, x)</annotation></semantics></math>
depend on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mn>0</mn></msub><mo>,</mo><msub><mi>W</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W_0, W_1</annotation></semantics></math>,
so always need to pick a reference individual. By default,
<code>semiivreg</code> computes the average individuals (for the
continuous/binary covariates and semi-IVs), and takes the ‘reference
level’ for factor variables.</p>
<p>In terms of estimation method, by default, <code>semivreg()</code>
estimates the second-stage with local polynomial regression, in the
spirit of the double residual regression for partially linear models of
<span class="citation">Robinson (1988)</span>. This is specified by
using the default <code>est_method="locpoly"</code>. This estimation as
the advantage of being robust to misspecification of the control
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>
functional form.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/raw-1.png" width="672" style="display: block; margin: auto;"></p>
<p>Let us report also the marginal treatment responses (MTR):</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mte_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; </span>
<span><span class="va">mtr_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span>;</span>
<span><span class="va">mtr_plot</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mtr-1.png" width="480" style="display: block; margin: auto;"></p>
<p><strong>Direct effect of the semi-IVs.</strong></p>
<p>Also estimates the effect of the semi-IV on their respective
potential outcomes. To see these:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">est0</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; lm(formula = formuladx, data = residd)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residuals:</span></span>
<span><span class="co">#&gt;     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">#&gt; -3.9165 -0.6515 -0.0026  0.6515  3.7574 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;    Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; w0 0.797735   0.005537   144.1   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residual standard error: 0.9643 on 24914 degrees of freedom</span></span>
<span><span class="co">#&gt; Multiple R-squared:  0.4545, Adjusted R-squared:  0.4545 </span></span>
<span><span class="co">#&gt; F-statistic: 2.076e+04 on 1 and 24914 DF,  p-value: &lt; 2.2e-16</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">est1</span><span class="op">)</span>;</span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; lm(formula = formuladx, data = residd)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residuals:</span></span>
<span><span class="co">#&gt;     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">#&gt; -3.6957 -0.6459 -0.0012  0.6513  3.7204 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;    Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; w1 0.507895   0.005501   92.33   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residual standard error: 0.9609 on 25084 degrees of freedom</span></span>
<span><span class="co">#&gt; Multiple R-squared:  0.2536, Adjusted R-squared:  0.2536 </span></span>
<span><span class="co">#&gt; F-statistic:  8525 on 1 and 25084 DF,  p-value: &lt; 2.2e-16</span></span>
<span><span class="co"># To be compared with:</span></span>
<span><span class="va">param_y0</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>; <span class="va">param_y1</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="co">#&gt; [1] 0.8</span></span>
<span><span class="co">#&gt; [1] 0.5</span></span></code></pre></div>
<p>Notice that these standard errors are biased because they do not take
into account that the propensity score is estimated.</p>
<p><strong>Standard errors.</strong></p>
<p>To get proper standard errors of the MTE/MTR and effects of the
semi-IVs with the default <code>"locpoly"</code>estimation method, use
the bootstrap with the function <code><a href="../reference/semiivreg.html">semiivreg_boot()</a></code>. This
takes longer to estimate though.</p>
<p><strong>Bandwidth Specification.</strong></p>
<p>By default, with <code>est_method="locpoly"</code>, if no bandwidth
is provided, the bandwidth are computed using the
<code>bw_method</code>. The default <code>bw_method</code> is a simple
<code>plug-in</code> rule of thumb estimator for pace. <em>Other methods
(e.g., cross validation) to be implemented later.</em> To extract the
bandwidth after the estimation, run <code>semiiv$bw</code>.</p>
<p>One can also pre-specify some of the bandwidth directly, as shown
below. The parameters <code>bwd</code> are the bandwidth for the first
residual regression of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>d</mi></msub><annotation encoding="application/x-tex">Y_d</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>d</mi></msub><annotation encoding="application/x-tex">W_d</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>)
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>P</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat{P}</annotation></semantics></math>,
that estimates respectively
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[Y_d|P]</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>W</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[W_d|P]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[X|P]</annotation></semantics></math>,
in order to get the effects of the semi-IVs on their potential outcomes.
For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>d</mi></msub><annotation encoding="application/x-tex">W_d</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
the order of the variable depends on the order specified in the original
<code>formula</code>. Be sure to match the variables in the correct
order (be careful with <code>factor</code> for example). One way to
check is to first run without specifying the bandwidth and then checking
the order of the variables in <code>semiiv$estimate$est0</code> and
<code>semiiv$estimate$est1</code>.</p>
<p><code>bw_y0</code> and <code>bw_y1</code> are the bandwidth for the
second part. They are much more important and governs the smoothness of
the MTE and MTR function.</p>
<p>For example, let us increase smoothing by increasing the
bandwidth.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span><span class="op">$</span><span class="va">bw</span></span>
<span><span class="co">#&gt; $bw0</span></span>
<span><span class="co">#&gt; [1] 0.05207205 0.04511177</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw1</span></span>
<span><span class="co">#&gt; [1] 0.05169498 0.04093002</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y0</span></span>
<span><span class="co">#&gt; [1] 0.09666612</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y1</span></span>
<span><span class="co">#&gt; [1] 0.08831236</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_method</span></span>
<span><span class="co">#&gt; [1] "rule-of-thumb"</span></span>
<span><span class="va">semiiv</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>,</span>
<span>                   bw_method <span class="op">=</span> <span class="st">"plug-in"</span>, bw_y0 <span class="op">=</span> <span class="fl">0.20</span>, bw_y1 <span class="op">=</span> <span class="fl">0.20</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/smooth-1.png" width="672" style="display: block; margin: auto;"></p>
<p><strong>Polynomial degree.</strong></p>
<p>One can also specify the degree of each local polynomial estimation
with <code>pol_degree_locpoly1</code> and
<code>pol_degree_locpoly2</code>. Following <span class="citation">Fan
and Gijbels (2003)</span> of setting the degree equal to the order of
the derivative function we want to estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math>,
by default we set <code>pol_degree_locpoly1 = 1</code> because there we
want to estimate a function directly, and
<code>pol_degree_locpoly2 = 2</code> because in the MTE/MTR stage we
want to estimate derivatives of the control function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>.</p>
<p><strong>Propensity Score estimation.</strong></p>
<p>One can also extract the propensity score estimation. With a large
number of observation, the fit is almost perfect and the bias due to the
fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is estimated will be very small.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">firststage</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">propensity</span></span>
<span><span class="co"># Cannot be compared with param_p directly if V gets rescaled -&gt; but can compare the predicted P with the truth</span></span>
<span><span class="va">Phat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">firststage</span>, newdata<span class="op">=</span><span class="va">data</span>, type<span class="op">=</span><span class="st">"response"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">Phat</span> <span class="op">-</span> <span class="va">data</span><span class="op">$</span><span class="va">P</span><span class="op">)</span> <span class="co"># almost perfect; </span></span>
<span><span class="co">#&gt;       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. </span></span>
<span><span class="co">#&gt; -0.0045356 -0.0008791  0.0001148  0.0001021  0.0010783  0.0043298</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="semi-iv-sieve-regression">semi-IV sieve regression<a class="anchor" aria-label="anchor" href="#semi-iv-sieve-regression"></a>
</h2>
<p>Another approach is to simply specify flexibly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>,
with polynomials for example, in the spirit of sieve estimation. This is
potentially less flexible (even though it still is), but as the
advantage of being faster and giving analytical confidence intervals
(biased because they do not take into account the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is estimated). To use this estimation method, specify
<code>est_method="sieve"</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv2</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>, </span>
<span>                    est_method<span class="op">=</span><span class="st">"sieve"</span>, pol_degree_sieve<span class="op">=</span><span class="fl">5</span>, </span>
<span>                    plotting<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">semiiv2</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; <span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">semiiv2</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/sieve-1.png" width="672" style="display: block; margin: auto;"></p>
<p><code>pol_degree_sieve</code> controls the flexibility of the control
function that is used, by controlling the degree of the polynomial used.
By default we set it to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>5</mn><annotation encoding="application/x-tex">5</annotation></semantics></math>.</p>
<p>Let us compare the two estimation methods results.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># If want to plot on the same plot, need some manipulation of the data</span></span>
<span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">RES</span> <span class="co"># take the original data</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">V</span> <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">Phat</span></span>
<span></span>
<span><span class="co"># for MTE:</span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">mte_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">V</span>, y<span class="op">=</span><span class="va">mte</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"#db93a4"</span>, na.rm<span class="op">=</span><span class="cn">TRUE</span>, data<span class="op">=</span><span class="va">dat</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># for MTR need some manipulation</span></span>
<span><span class="va">dat_plot</span> <span class="op">=</span> <span class="va">dat</span>;</span>
<span><span class="va">dat1</span> <span class="op">=</span> <span class="va">dat_plot</span>; <span class="va">dat1</span><span class="op">$</span><span class="va">mtr</span> <span class="op">=</span> <span class="va">dat_plot</span><span class="op">$</span><span class="va">mtr1</span>; <span class="va">dat1</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">dat0</span> <span class="op">=</span> <span class="va">dat_plot</span>; <span class="va">dat0</span><span class="op">$</span><span class="va">mtr</span> <span class="op">=</span> <span class="va">dat_plot</span><span class="op">$</span><span class="va">mtr0</span>; <span class="va">dat0</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fl">0</span>;</span>
<span><span class="va">dat2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">dat1</span>, <span class="va">dat0</span><span class="op">)</span></span>
<span><span class="va">dat2</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.factor</a></span><span class="op">(</span><span class="va">dat2</span><span class="op">$</span><span class="va">Treatment</span><span class="op">)</span></span>
<span></span>
<span><span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">mtr_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">V</span>, y<span class="op">=</span><span class="va">mtr</span>, col<span class="op">=</span><span class="va">Treatment</span>, group<span class="op">=</span><span class="va">Treatment</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, na.rm<span class="op">=</span><span class="cn">TRUE</span>, data<span class="op">=</span><span class="va">dat2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/sievecompare-1.png" width="672" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="comparison-with-the-truth">Comparison with the truth<a class="anchor" aria-label="anchor" href="#comparison-with-the-truth"></a>
</h2>
<p>Let us compute the ‘true’ underlying MTE. Given the model
specification, with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>U</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>U</mi><mn>1</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\begin{pmatrix}
U_0 \\
U_1 
\end{pmatrix}
\sim N \left( \begin{pmatrix} 0 \\ 0 \end{pmatrix},
\begin{pmatrix}
\sigma_{U_0}^2 &amp; \sigma_{U_0U_1} \\
\sigma_{U_0U_1} &amp; \sigma_{U_1}^2
\end{pmatrix}
\right)
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo>−</mo><msub><mi>U</mi><mn>0</mn></msub><mo>−</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> where </mtext><mspace width="0.333em"></mspace></mrow><mi>C</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>C</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊥</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mn>0</mn></msub><mo>,</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex"> V = - (U_1 - U_0 - C) \text{ where } C \sim N(0, \sigma_C^2) \perp (U_0, U_1). </annotation></semantics></math>
Simple computation gives that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>−</mo><mn>2</mn><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub><mo>+</mo><msubsup><mi>σ</mi><mi>C</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">V \sim N(0, \sigma_{U_0}^2 + \sigma_{U_1}^2 - 2 \sigma_{U_0U_1} + \sigma_C^2)</annotation></semantics></math>.
Let us introduce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>D</mi></msub><mo>=</mo><msub><mi>F</mi><mi>V</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U_D = F_V(V)</annotation></semantics></math>
the uniform normalized
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
shock. Now,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>U</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>U</mi><mi>D</mi></msub><mo>=</mo><mi>u</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(u) = \mathbb{E}[U_d | U_D=u]</annotation></semantics></math>.
So, we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>U</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>V</mi><mo>=</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(u) = \mathbb{E}[U_d | V=F_V^{-1}(u)]</annotation></semantics></math>.
Given the specification above,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>d</mi></msub><annotation encoding="application/x-tex">U_d</annotation></semantics></math>
are bivariate normal and we have that:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup><mo>−</mo><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mrow><msubsup><mi>σ</mi><mi>V</mi><mn>2</mn></msubsup></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>μ</mi><mi>V</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><mo>−</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>+</mo><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mrow><msubsup><mi>σ</mi><mi>V</mi><mn>2</mn></msubsup></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>μ</mi><mi>V</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
k_0(u) &amp;= \frac{\sigma_{U_0}^2 - \sigma_{U_0U_1}}{\sigma_V^2} \big(F_{V}^{-1}(u) - \mu_V \big), \\
k_1(u) &amp;= \frac{-\sigma_{U_1}^2 + \sigma_{U_0U_1}}{\sigma_V^2} \big(F_{V}^{-1}(u) - \mu_V \big)
\end{aligned}
</annotation></semantics></math> Then, the true MTR and MTE are given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>δ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>w</mi><mn>0</mn></msub><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>δ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>β</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex"> 
\begin{aligned}
MTR_0(w_0, u) &amp;= \delta_0 + w_0 \beta_0 +  k_0(u), \\
MTR_1(w_1, u) &amp;= \delta_1 + w_1 \beta_1 +  k_1(u), \\
MTE(w_0, w_1, u) &amp;= MTR_1(w_0, u) - MTR_0(w_1, u)
\end{aligned}
</annotation></semantics></math></p>
<p>Evaluate the MTR and MTE at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(w_0, w_1) = (0, 0)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># True MTE and MTR estimations </span></span>
<span><span class="va">seq_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, by<span class="op">=</span><span class="fl">0.001</span><span class="op">)</span>; </span>
<span><span class="va">w0</span> <span class="op">=</span> <span class="fl">0</span>; <span class="va">w1</span> <span class="op">=</span> <span class="fl">0</span>; </span>
<span><span class="va">sigma_V2</span> <span class="op">=</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="fl">2</span><span class="op">*</span><span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="co"># = var(V); var(data$V)</span></span>
<span><span class="va">covU0V</span> <span class="op">=</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="co"># = cov(data$U0, data$V)</span></span>
<span><span class="va">covU1V</span> <span class="op">=</span> <span class="op">-</span><span class="va">param_error</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="co"># = cov(data$U1, data$V)</span></span>
<span><span class="va">ku0</span> <span class="op">=</span> <span class="va">covU0V</span><span class="op">/</span><span class="va">sigma_V2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="va">seq_p</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0</span><span class="op">)</span> <span class="co"># 0 = mean(V)</span></span>
<span><span class="va">ku1</span> <span class="op">=</span> <span class="va">covU1V</span><span class="op">/</span><span class="va">sigma_V2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="va">seq_p</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0</span><span class="op">)</span> <span class="co"># 0 = mean(V)</span></span>
<span><span class="va">true_mtr0</span> <span class="op">=</span> <span class="va">param_y0</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_y0</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="va">w0</span> <span class="op">+</span> <span class="va">ku0</span></span>
<span><span class="va">true_mtr1</span> <span class="op">=</span> <span class="va">param_y1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_y1</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="va">w1</span> <span class="op">+</span> <span class="va">ku1</span></span>
<span><span class="va">true_mte</span> <span class="op">=</span> <span class="va">true_mtr1</span> <span class="op">-</span> <span class="va">true_mtr0</span></span>
<span></span>
<span><span class="va">newdata</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>Ud<span class="op">=</span><span class="va">seq_p</span>, w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">newdata</span><span class="op">$</span><span class="va">true_mte</span> <span class="op">=</span> <span class="va">true_mte</span>; <span class="va">newdata</span><span class="op">$</span><span class="va">true_mtr1</span> <span class="op">=</span> <span class="va">true_mtr1</span>; <span class="va">newdata</span><span class="op">$</span><span class="va">true_mtr0</span> <span class="op">=</span> <span class="va">true_mtr0</span></span>
<span></span>
<span><span class="co">## # Remark: alternative estimation method if the truth does not have a simple closed form formula:</span></span>
<span><span class="co">## data$diff = data$y1 - data$y0; pol_degree=5</span></span>
<span><span class="co">## true_model_mte = lm(diff~w1 + w0 + poly(Ud, pol_degree, raw=TRUE), data); # MTE</span></span>
<span><span class="co">## true_model_mtr1 = lm(y1 ~w1+poly(Ud, pol_degree, raw=TRUE), data) # MTR1</span></span>
<span><span class="co">## true_model_mtr0 = lm(y0 ~w0+poly(Ud, pol_degree, raw=TRUE), data) # MTR0</span></span>
<span><span class="co">## newdata$true_mte = predict(true_model_mte, newdata); </span></span>
<span><span class="co">## newdata$true_mtr1 = predict(true_model_mtr1, newdata); newdata$true_mtr0 = predict(true_model_mtr0, newdata)</span></span>
<span></span>
<span></span>
<span><span class="co"># Comparison:</span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">mte_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mte</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"red"</span><span class="op">)</span></span>
<span><span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">mtr_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mtr1</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"blue"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mtr0</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"orange"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mte_true-1.png" width="672" style="display: block; margin: auto;"></p>
<p>Overall, we see that on the common support, the MTE are very
precisely estimated here. What is remarkable is that we do not exploit
the parametric knowledge of the underlying distribution of the shocks at
all.</p>
<p>Compared to the homogenous treatment effect models, the estimation
with heterogenous treatment effects requires more observations.
Otherwise, the MTE are not well estimated at the tails of the common
support. A solution is just to trim the estimation on the set on which
the parameters are well identified then.</p>
</div>
<div class="section level2">
<h2 id="other-options">Other options<a class="anchor" aria-label="anchor" href="#other-options"></a>
</h2>
<p><strong>Trimming the Support.</strong></p>
<p>These seems relatively well estimated, except at the tails where the
common support is not entirely satisfied, while the MTE is only
identified on the common support. If one wants to restrict the
estimation to a given common support, it is very easy to do in
<code><a href="../reference/semiivreg.html">semiivreg()</a></code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv1</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, </span>
<span>                    ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>, </span>
<span>                    common_supp_trim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.90</span><span class="op">)</span>,</span>
<span>                    plotting<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">mte_plot</span> <span class="op">=</span> <span class="va">semiiv1</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; <span class="va">mtr_plot</span> <span class="op">=</span> <span class="va">semiiv1</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span>;</span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mtr_plot</span>, <span class="va">mte_plot</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mte_trim1-1.png" width="672" style="display: block; margin: auto;"></p>
<p><strong>Post-estimation prediction.</strong> Imagine after estimating
one wants to estimate the model for several individuals. One way is to
directly specify several ref_indiv when running the initial regression.
But if it’s already estimated, one can simply use the
<code>semiiv_predict</code> function. It also allows to predict only at
a subset of specific values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">newdata</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, by<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span> <span class="co"># Predict the outcome</span></span>
<span></span>
<span><span class="va">pred</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiiv_predict</a></span><span class="op">(</span><span class="va">semiiv1</span>, newdata<span class="op">=</span><span class="va">newdata</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pred</span><span class="op">$</span><span class="va">RES</span><span class="op">)</span> <span class="co"># the predicted values; -&gt; can then be used to redo plots for example. </span></span>
<span><span class="co">#&gt; NULL</span></span>
<span><span class="va">pred</span><span class="op">$</span><span class="va">deltaX</span> <span class="co"># provides the shift in effect of X and Wd -&gt; may be the only thing we care about, know that shifts the curve</span></span>
<span><span class="co">#&gt;     w0 w1 id    delta0X delta1X  se_delta0X se_delta1X</span></span>
<span><span class="co">#&gt; 1 -1.0  0  1 -0.7962510       0 0.005702196          0</span></span>
<span><span class="co">#&gt; 2 -0.5  0  2 -0.3981255       0 0.002851098          0</span></span>
<span><span class="co">#&gt; 3  0.0  0  3  0.0000000       0 0.000000000          0</span></span>
<span><span class="co">#&gt; 4  0.5  0  4  0.3981255       0 0.002851098          0</span></span>
<span><span class="co">#&gt; 5  1.0  0  5  0.7962510       0 0.005702196          0</span></span></code></pre></div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-bruneel2024" class="csl-entry">
Bruneel-Zupanc, Christophe. 2024. <span>“Don’t (Fully) Exclude Me, It’s
Not Necessary! Identification with Semi-IVs.”</span> <a href="https://arxiv.org/abs/2303.12667" class="external-link">https://arxiv.org/abs/2303.12667</a>.
</div>
<div id="ref-fangijbels2003" class="csl-entry">
Fan, Jianqing., and Irène. Gijbels. 2003. <em>Local Polynomial Modelling
and Its Applications.</em> Monographs on Statistics and Applied
Probability 66. Boca Raton: Chapman; Hall/CRC.
</div>
<div id="ref-heckman2006understanding" class="csl-entry">
Heckman, James J, Sergio Urzua, and Edward Vytlacil. 2006.
<span>“Understanding Instrumental Variables in Models with Essential
Heterogeneity.”</span> <em>The Review of Economics and Statistics</em>
88 (3): 389–432.
</div>
<div id="ref-heckmanvytlacil2007b" class="csl-entry">
Heckman, James J., and Edward J. Vytlacil. 2007. <span>“Chapter 71
Econometric Evaluation of Social Programs, Part II: Using the Marginal
Treatment Effect to Organize Alternative Econometric Estimators to
Evaluate Social Programs, and to Forecast Their Effects in New
Environments.”</span> In, edited by James J. Heckman and Edward E.
Leamer, 6:4875–5143. Handbook of Econometrics. Elsevier.
https://doi.org/<a href="https://doi.org/10.1016/S1573-4412(07)06071-0" class="external-link">https://doi.org/10.1016/S1573-4412(07)06071-0</a>.
</div>
<div id="ref-robinson1988root" class="csl-entry">
Robinson, Peter M. 1988. <span>“Root-n-Consistent Semiparametric
Regression.”</span> <em>Econometrica: Journal of the Econometric
Society</em>, 931–54.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Christophe Bruneel.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
