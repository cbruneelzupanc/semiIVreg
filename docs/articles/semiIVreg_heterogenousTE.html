<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Estimator Performance: general heterogenous treatment effect model • semiIVreg</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Estimator Performance: general heterogenous treatment effect model">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="default" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">semiIVreg</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/semiIVreg.html">Model and Guidelines</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-simulations" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Simulations</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-simulations">
<li><a class="dropdown-item" href="../articles/semiIVreg_homogenousTE.html">Estimation with Homogenous Treatment Effect</a></li>
    <li><a class="dropdown-item" href="../articles/semiIVreg_heterogenousTE.html">Estimation with general Heterogenous Treatment Effect</a></li>
  </ul>
</li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-more" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">More</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-more">
<li><a class="dropdown-item" href="../articles/simul_data.html">Roy model simulation</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://twitter.com/CBruneelZupanc" aria-label="Twitter"><span class="fa fa-twitter"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/cbruneelzupanc/semiIVreg" aria-label="Github"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Estimator Performance: general heterogenous treatment effect model</h1>
                        <h4 data-toc-skip class="author"><a href="https://www.cbruneel.com/" class="external-link">Christophe Bruneel-Zupanc</a></h4>
            
            <h4 data-toc-skip class="date">Last modified:
2024-07-22</h4>
      

      <div class="d-none name"><code>semiIVreg_heterogenousTE.Rmd</code></div>
    </div>

    
    
<p>Let us compare the performance of the semi-IV estimator in a
<strong>generalized Roy model</strong> with <strong>heterogenous
treatment effects</strong>. The simulation specification comes from the
Appendix of <span class="citation">Bruneel-Zupanc (2024)</span> (Monte
Carlo with Heterogenous treatment effect). It is close to the
counterpart standard IV simulated Roy models used in <span class="citation">James J. Heckman, Urzua, and Vytlacil (2006)</span> or
<span class="citation">James J. Heckman and Vytlacil (2007)</span>.</p>
<div class="section level2">
<h2 id="simulate-data">Simulate data<a class="anchor" aria-label="anchor" href="#simulate-data"></a>
</h2>
<p>We simulate generalized Roy models using the
<code><a href="../reference/simul_data.html">simul_data()</a></code>function. See the documentation of the function
for details about the model. Depending on the chosen parameters, we can
simulate a model with homogenous/heterogenous treatment effects, as well
as with valid IVs eventually. That’s what we will do here. In every
simulation we do not include covariates (set all their effect to 0), but
these can be easily included.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Model</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://www.cbruneel.com/" class="external-link">semiIVreg</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; KernSmooth 2.23 loaded</span></span>
<span><span class="co">#&gt; Copyright M. P. Wand 1997-2009</span></span>
<span><span class="co">#&gt; Loading required package: zoo</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Attaching package: 'zoo'</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:data.table':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     yearmon, yearqtr</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:base':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     as.Date, as.Date.numeric</span></span>
<span><span class="va">N</span> <span class="op">=</span> <span class="fl">50000</span>; <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="co"># Specification</span></span>
<span><span class="va">model_type</span> <span class="op">=</span> <span class="st">"heterogenous"</span></span>
<span><span class="va">param_error</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1.5</span>, <span class="fl">0.5</span>, <span class="fl">1.5</span><span class="op">)</span> <span class="co"># var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous</span></span>
<span><span class="va">param_Z</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0.8</span>, <span class="fl">0.3</span><span class="op">)</span> <span class="co"># meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1</span></span>
<span><span class="va">param_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.2</span>, <span class="op">-</span><span class="fl">1.2</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ</span></span>
<span><span class="va">param_y0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3.2</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># intercept, effect of Wd, effect of state, effect of parent educ;</span></span>
<span><span class="va">param_y1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3.2</span><span class="op">+</span><span class="fl">0.4</span>, <span class="fl">1.3</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="co"># the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ;</span></span>
<span><span class="va">param_genX</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="../reference/simul_data.html">simul_data</a></span><span class="op">(</span><span class="va">N</span>, <span class="va">model_type</span>, <span class="va">param_y0</span>, <span class="va">param_y1</span>, <span class="va">param_p</span>, <span class="va">param_Z</span>, <span class="va">param_genX</span>, <span class="va">param_error</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="semi-iv-regression">semi-IV regression<a class="anchor" aria-label="anchor" href="#semi-iv-regression"></a>
</h2>
<p>Let us apply directly the <code><a href="../reference/semiivreg.html">semiivreg()</a></code>function. Compute
the MTE and MTR for a reference individuals with average value of the
semi-IVs, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>W</mi><mn>0</mn></msub><mo>,</mo><msub><mi>W</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(W_0, W_1) = (0, 0)</annotation></semantics></math>
here. Remark: the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo>,</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">MTE(u, w_0, w_1, x)</annotation></semantics></math>
depend on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mn>0</mn></msub><mo>,</mo><msub><mi>W</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W_0, W_1</annotation></semantics></math>,
so always need to pick a reference individual. By default,
<code>semiivreg</code> computes the average individuals (for the
continuous/binary covariates and semi-IVs), and takes the ‘reference
level’ for factor variables.</p>
<p>In terms of estimation method, by default, <code>semivreg()</code>
estimates the second-stage with local polynomial regression, in the
spirit of the double residual regression for partially linear models of
<span class="citation">Robinson (1988)</span>. This is specified by
using the default <code>est_method="locpoly"</code>. This estimation as
the advantage of being robust to misspecification of the control
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>
functional form.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot().</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/raw-1.png" width="672" style="display: block; margin: auto;"></p>
<p>Let us report also the marginal treatment responses (MTR):</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mte_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; </span>
<span><span class="va">mtr_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span>;</span>
<span><span class="va">mtr_plot</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mtr-1.png" width="480" style="display: block; margin: auto;"></p>
<p>Attention: <strong>all the standard errors reported are wrong (too
narrow)!</strong> They do not take into account the fact that the
propensity score is estimated. For <code>locpoly</code> estimation (the
default), these are simply the standard errors around
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(v)</annotation></semantics></math>,
they do not take into account the error in the effect of the covariates.
To get proper standard errors, one should use the bootstrap.</p>
<p>Other options: to speed things up (especially useful in the first
residual regression), can use <code>fast_robinson1 = TRUE</code> (for
the 1st residual regression of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>d</mi></msub><annotation encoding="application/x-tex">W_d</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>)
and <code>fast_robinson2 = TRUE</code> (for the second residual
regression). The <code>fast_robinson</code> uses the
<code>locpoly()</code> function from <code>KernSmooth</code> package,
which is much faster than the default routine we implemented. It has
several drawbacks though: (i) only implemented for
<code>kernel="gaussian"</code>, (ii) does not compute standard errors
around
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(v)</annotation></semantics></math>
estimates (but anyway, these are not completely correct), (iii) cannot
use external weights for the data.</p>
<p><strong>Direct effect of the semi-IVs.</strong></p>
<p>Also estimates the effect of the semi-IV on their respective
potential outcomes. To see these:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">est0</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; lm(formula = formuladx, data = residd, weights = weightsd)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residuals:</span></span>
<span><span class="co">#&gt;     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">#&gt; -3.7603 -0.6498 -0.0060  0.6563  3.6457 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;    Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; w0 0.996692   0.008595     116   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residual standard error: 0.9762 on 26778 degrees of freedom</span></span>
<span><span class="co">#&gt; Multiple R-squared:  0.3343, Adjusted R-squared:  0.3343 </span></span>
<span><span class="co">#&gt; F-statistic: 1.345e+04 on 1 and 26778 DF,  p-value: &lt; 2.2e-16</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">est1</span><span class="op">)</span>;</span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; lm(formula = formuladx, data = residd, weights = weightsd)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residuals:</span></span>
<span><span class="co">#&gt;     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">#&gt; -4.5990 -0.7789 -0.0022  0.7614  4.3267 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Coefficients:</span></span>
<span><span class="co">#&gt;    Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">#&gt; w1 1.287222   0.009057   142.1   &lt;2e-16 ***</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Residual standard error: 1.14 on 23220 degrees of freedom</span></span>
<span><span class="co">#&gt; Multiple R-squared:  0.4652, Adjusted R-squared:  0.4652 </span></span>
<span><span class="co">#&gt; F-statistic: 2.02e+04 on 1 and 23220 DF,  p-value: &lt; 2.2e-16</span></span>
<span><span class="co"># To be compared with:</span></span>
<span><span class="va">param_y0</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>; <span class="va">param_y1</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="co">#&gt; [1] 1</span></span>
<span><span class="co">#&gt; [1] 1.3</span></span></code></pre></div>
<p>Notice that these standard errors are biased because they do not take
into account that the propensity score is estimated.</p>
<p><strong>Standard errors.</strong></p>
<p>To get proper standard errors of the MTE/MTR and effects of the
semi-IVs with the default <code>"locpoly"</code>estimation method, use
the bootstrap with the function <code><a href="../reference/semiivreg.html">semiivreg_boot()</a></code>. This
takes longer to estimate though.</p>
<p><strong>Bandwidth Specification.</strong></p>
<p>By default, with <code>est_method="locpoly"</code>, if no bandwidth
is provided, the bandwidth are computed using the
<code>bw_method</code>. The default <code>bw_method</code> is
simplistic: it picks the bandwidth as the specified fraction (1/5th) of
the range of the support (rounded to the 3rd digit). You can set
<code>bw_method</code> to any number (between 0 and 1) to pick the
bandwidth as a function of the support automatically.</p>
<p>One can also implement <em>optimal bandwidth selection</em> methods,
from the package <code>nprobust</code> (see <span class="citation">Calonico, Cattaneo, and Farrell (2019)</span>). In
particular, <code>bw_method = "mse-dpi"</code> and
<code>="mse-rot"</code> implement the optimal (constant) bandwidth which
minimizes the (integrated) mean squared error of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k_1(v) - k_0(v)</annotation></semantics></math>
function, using either direct plug-in (dpi) or rule-of-thumb (rot)
formula. For more details, see <span class="citation">Calonico,
Cattaneo, and Farrell (2019)</span> or <span class="citation">Fan and
Gijbels (1996)</span>, or <span class="citation">Wand and Jones
(1994)</span>. Later updates of the package will allow for variable
bandwidth (as already implemented in <code>nprobust</code>). Notice that
in the second residual regression of Robinson, we want to estimate the
<em>derivative</em> of the local polynomial function, so we find the
optimal bandwidth for this derivative, hence the use of the plug-in and
rule-of-thumb methods, which are well suited for this (see <span class="citation">Fan and Gijbels (1996)</span>). The estimation of the
optimal bandwidth on large sample can take a long time (exponential
increase with sample size). So, by default we specify
<code>bw_subsamp_size = 10000</code> such that the optimal bandwidth is
computed on a “small” subsample of size 10,000. Requires to
<code><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed()</a></code> before running <code>semiivreg</code> for
replicability. Set it to <code>NULL</code> (or to some very large
values) to compute the bandwidth on the full sample.</p>
<p>Alternatively, one can pre-specify some of the bandwidth directly, as
shown below. The parameters <code>bwd</code> are the bandwidth for the
first residual regression of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>d</mi></msub><annotation encoding="application/x-tex">Y_d</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>d</mi></msub><annotation encoding="application/x-tex">W_d</annotation></semantics></math>
(and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>)
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>P</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\widehat{P}</annotation></semantics></math>,
that estimates respectively
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[Y_d|P]</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>W</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[W_d|P]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>X</mi><mo stretchy="false" form="prefix">|</mo><mi>P</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[X|P]</annotation></semantics></math>,
in order to get the effects of the semi-IVs on their potential outcomes.
For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>d</mi></msub><annotation encoding="application/x-tex">W_d</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
the order of the variable depends on the order specified in the original
<code>formula</code>. Be sure to match the variables in the correct
order (be careful with <code>factor</code> for example). One way to
check is to first run without specifying the bandwidth and then checking
the order of the variables in <code>semiiv$estimate$est0</code> and
<code>semiiv$estimate$est1</code>.<br>
If one specifies only one value in bw0 and bw1, it will be applied to
all the covariates.</p>
<p><code>bw_y0</code>, <code>bw_y1</code> are the bandwidth for the
second residual regression, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k_0(v)</annotation></semantics></math>
(MTR0)
and<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k_1(v)</annotation></semantics></math>
(MTR1) respectively. They are important since they govern the smoothness
of the MTR, and thus of the MTE function. <code>bw_y0</code> also serves
as the bw for the local-IV estimation of the MTE directly.</p>
<p>Let us check the bandwidth from the previous computation (default was
1/5th of the support rule).</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span><span class="op">$</span><span class="va">bw</span></span>
<span><span class="co">#&gt; $bw0</span></span>
<span><span class="co">#&gt; [1] 0.199 0.199</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw1</span></span>
<span><span class="co">#&gt; [1] 0.199 0.199</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y0</span></span>
<span><span class="co">#&gt; [1] 0.199</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y1</span></span>
<span><span class="co">#&gt; [1] 0.199</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_mte</span></span>
<span><span class="co">#&gt; [1] 0.199</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_method</span></span>
<span><span class="co">#&gt; [1] 0.2</span></span></code></pre></div>
<p>Re-estimate the model with optimal bandwidth selection
(<code>mse-dpi</code> rule) (<code>print_progress=TRUE</code> is a
reporting option to see the progress of the function).</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">semiiv</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>,</span>
<span>                   bw_method <span class="op">=</span> <span class="st">"mse-dpi"</span>, bw_subsamp_size<span class="op">=</span><span class="fl">10000</span>, </span>
<span>                   print_progress<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Estimating first stage... First stage estimated.       </span></span>
<span><span class="co">#&gt; 2nd stage: Estimating MTR and MTE... </span></span>
<span><span class="co">#&gt; D= 0, Robinson 1st residual regression of X on P...               </span></span>
<span><span class="co">#&gt; Progress: 1/2                              Progress: 2/2                              D= 1, Robinson 1st residual regression of X on P...               </span></span>
<span><span class="co">#&gt; Progress: 1/2                              Progress: 2/2                              Robinson 2nd stage: Bandwidth Selection...                           Robinson 2nd stage: Estimation of k0(v) and k1(v)... </span></span>
<span><span class="co">#&gt; Estimation complete.</span></span>
<span><span class="co">#&gt; Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot().</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/smooth2-1.png" width="672" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span><span class="op">$</span><span class="va">bw</span></span>
<span><span class="co">#&gt; $bw0</span></span>
<span><span class="co">#&gt; [1] 0.08202580 0.04809258</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw1</span></span>
<span><span class="co">#&gt; [1] 0.1326332 0.1089366</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y0</span></span>
<span><span class="co">#&gt; [1] 0.1261527</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_y1</span></span>
<span><span class="co">#&gt; [1] 0.1261527</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_mte</span></span>
<span><span class="co">#&gt; [1] 0.1261527</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $bw_method</span></span>
<span><span class="co">#&gt; [1] "mse-dpi"</span></span></code></pre></div>
<p>Now, illustrate how we can directly specify the bandwidth (which
adjusts the smoothness of the estimation). Remark: the
<code>bw_method</code> does not matter if we specify all the
bandwidth.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>,</span>
<span>                   bw0<span class="op">=</span><span class="fl">0.05</span>, bw1<span class="op">=</span><span class="fl">0.05</span>, bw_y0 <span class="op">=</span> <span class="fl">0.126</span>, bw_y1 <span class="op">=</span> <span class="fl">0.126</span><span class="op">)</span></span>
<span><span class="co">#&gt; Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot().</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/smooth3-1.png" width="672" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Update the mtr and mte plots with the "optimal" bw </span></span>
<span><span class="va">mte_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; </span>
<span><span class="va">mtr_plot</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span>;</span></code></pre></div>
<p><strong>Polynomial degree.</strong></p>
<p>One can also specify the degree of each local polynomial estimation
with <code>pol_degree_locpoly1</code> and
<code>pol_degree_locpoly2</code>. Following <span class="citation">Fan
and Gijbels (1996)</span> of setting the degree equal to the order of
the derivative function we want to estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math>,
by default we set <code>pol_degree_locpoly1 = 1</code> because there we
want to estimate a function directly, and
<code>pol_degree_locpoly2 = 2</code> because in the MTE/MTR stage we
want to estimate derivatives of the control function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>.</p>
<p><strong>Propensity Score estimation.</strong></p>
<p>One can also extract the propensity score estimation. With a large
number of observation, the fit is almost perfect and the bias due to the
fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is estimated will be very small.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">firststage</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">estimate</span><span class="op">$</span><span class="va">propensity</span></span>
<span><span class="co"># Cannot be compared with param_p directly if V gets rescaled -&gt; but can compare the predicted P with the truth</span></span>
<span><span class="va">Phat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">firststage</span>, newdata<span class="op">=</span><span class="va">data</span>, type<span class="op">=</span><span class="st">"response"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">Phat</span> <span class="op">-</span> <span class="va">data</span><span class="op">$</span><span class="va">P</span><span class="op">)</span> <span class="co"># almost perfect; </span></span>
<span><span class="co">#&gt;        Min.     1st Qu.      Median        Mean     3rd Qu.        Max. </span></span>
<span><span class="co">#&gt; -0.00145960 -0.00086220  0.00010782  0.00002379  0.00092685  0.00132015</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="semi-iv-sieve-regression">semi-IV sieve regression<a class="anchor" aria-label="anchor" href="#semi-iv-sieve-regression"></a>
</h2>
<p>Another approach is to simply specify flexibly
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\kappa_d(u)</annotation></semantics></math>,
with polynomials for example, in the spirit of sieve estimation. This is
potentially less flexible (even though it still is), but as the
advantage of being faster and giving analytical confidence intervals
(biased because they do not take into account the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is estimated). To use this estimation method, specify
<code>est_method="sieve"</code>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv2</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>, </span>
<span>                    est_method<span class="op">=</span><span class="st">"sieve"</span>, pol_degree_sieve<span class="op">=</span><span class="fl">3</span>, </span>
<span>                    plotting<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">semiiv2</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; <span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">semiiv2</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/sieve-1.png" width="672" style="display: block; margin: auto;"></p>
<p><code>pol_degree_sieve</code> controls the flexibility of the control
function that is used, by controlling the degree of the polynomial used.
By default we set it to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>5</mn><annotation encoding="application/x-tex">5</annotation></semantics></math>.</p>
<p>Let us compare the two estimation methods results.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># If want to plot on the same plot, need some manipulation of the data</span></span>
<span></span>
<span><span class="va">dat</span> <span class="op">=</span> <span class="va">semiiv</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">RES</span> <span class="co"># take the original data</span></span>
<span><span class="va">dat</span><span class="op">$</span><span class="va">V</span> <span class="op">=</span> <span class="va">dat</span><span class="op">$</span><span class="va">Phat</span></span>
<span></span>
<span><span class="co"># for MTE:</span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">mte_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">V</span>, y<span class="op">=</span><span class="va">mte</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"#db93a4"</span>, na.rm<span class="op">=</span><span class="cn">TRUE</span>, data<span class="op">=</span><span class="va">dat</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># for MTR need some manipulation</span></span>
<span><span class="va">dat_plot</span> <span class="op">=</span> <span class="va">dat</span>;</span>
<span><span class="va">dat1</span> <span class="op">=</span> <span class="va">dat_plot</span>; <span class="va">dat1</span><span class="op">$</span><span class="va">mtr</span> <span class="op">=</span> <span class="va">dat_plot</span><span class="op">$</span><span class="va">mtr1</span>; <span class="va">dat1</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">dat0</span> <span class="op">=</span> <span class="va">dat_plot</span>; <span class="va">dat0</span><span class="op">$</span><span class="va">mtr</span> <span class="op">=</span> <span class="va">dat_plot</span><span class="op">$</span><span class="va">mtr0</span>; <span class="va">dat0</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fl">0</span>;</span>
<span><span class="va">dat2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">dat1</span>, <span class="va">dat0</span><span class="op">)</span></span>
<span><span class="va">dat2</span><span class="op">$</span><span class="va">Treatment</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.factor</a></span><span class="op">(</span><span class="va">dat2</span><span class="op">$</span><span class="va">Treatment</span><span class="op">)</span></span>
<span></span>
<span><span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">mtr_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">V</span>, y<span class="op">=</span><span class="va">mtr</span>, col<span class="op">=</span><span class="va">Treatment</span>, group<span class="op">=</span><span class="va">Treatment</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, na.rm<span class="op">=</span><span class="cn">TRUE</span>, data<span class="op">=</span><span class="va">dat2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/sievecompare-1.png" width="672" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="comparison-with-the-truth">Comparison with the truth<a class="anchor" aria-label="anchor" href="#comparison-with-the-truth"></a>
</h2>
<p>Let us compute the ‘true’ underlying MTE. Given the model
specification, with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>U</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>U</mi><mn>1</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\begin{pmatrix}
U_0 \\
U_1 
\end{pmatrix}
\sim N \left( \begin{pmatrix} 0 \\ 0 \end{pmatrix},
\begin{pmatrix}
\sigma_{U_0}^2 &amp; \sigma_{U_0U_1} \\
\sigma_{U_0U_1} &amp; \sigma_{U_1}^2
\end{pmatrix}
\right)
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo>−</mo><msub><mi>U</mi><mn>0</mn></msub><mo>−</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> where </mtext><mspace width="0.333em"></mspace></mrow><mi>C</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>C</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊥</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>U</mi><mn>0</mn></msub><mo>,</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex"> V = - (U_1 - U_0 - C) \text{ where } C \sim N(0, \sigma_C^2) \perp (U_0, U_1). </annotation></semantics></math>
Simple computation gives that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>−</mo><mn>2</mn><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub><mo>+</mo><msubsup><mi>σ</mi><mi>C</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">V \sim N(0, \sigma_{U_0}^2 + \sigma_{U_1}^2 - 2 \sigma_{U_0U_1} + \sigma_C^2)</annotation></semantics></math>.
Let us introduce
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>D</mi></msub><mo>=</mo><msub><mi>F</mi><mi>V</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U_D = F_V(V)</annotation></semantics></math>
the uniform normalized
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
shock. Now,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>U</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>U</mi><mi>D</mi></msub><mo>=</mo><mi>u</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(u) = \mathbb{E}[U_d | U_D=u]</annotation></semantics></math>.
So, we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>U</mi><mi>d</mi></msub><mo stretchy="false" form="prefix">|</mo><mi>V</mi><mo>=</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">k_d(u) = \mathbb{E}[U_d | V=F_V^{-1}(u)]</annotation></semantics></math>.
Given the specification above,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>d</mi></msub><annotation encoding="application/x-tex">U_d</annotation></semantics></math>
are bivariate normal and we have that:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><msubsup><mi>σ</mi><msub><mi>U</mi><mn>0</mn></msub><mn>2</mn></msubsup><mo>−</mo><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mrow><msubsup><mi>σ</mi><mi>V</mi><mn>2</mn></msubsup></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>μ</mi><mi>V</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><mo>−</mo><msubsup><mi>σ</mi><msub><mi>U</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>+</mo><msub><mi>σ</mi><mrow><msub><mi>U</mi><mn>0</mn></msub><msub><mi>U</mi><mn>1</mn></msub></mrow></msub></mrow><msubsup><mi>σ</mi><mi>V</mi><mn>2</mn></msubsup></mfrac><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>F</mi><mi>V</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>μ</mi><mi>V</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
k_0(u) &amp;= \frac{\sigma_{U_0}^2 - \sigma_{U_0U_1}}{\sigma_V^2} \big(F_{V}^{-1}(u) - \mu_V \big), \\
k_1(u) &amp;= \frac{-\sigma_{U_1}^2 + \sigma_{U_0U_1}}{\sigma_V^2} \big(F_{V}^{-1}(u) - \mu_V \big)
\end{aligned}
</annotation></semantics></math> Then, the true MTR and MTE are given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>δ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>w</mi><mn>0</mn></msub><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>δ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>β</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>M</mi><mi>T</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>M</mi><mi>T</mi><msub><mi>R</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex"> 
\begin{aligned}
MTR_0(w_0, u) &amp;= \delta_0 + w_0 \beta_0 +  k_0(u), \\
MTR_1(w_1, u) &amp;= \delta_1 + w_1 \beta_1 +  k_1(u), \\
MTE(w_0, w_1, u) &amp;= MTR_1(w_0, u) - MTR_0(w_1, u)
\end{aligned}
</annotation></semantics></math></p>
<p>Evaluate the MTR and MTE at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>,</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(w_0, w_1) = (0, 0)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># Underlying true MTE and MTR:</span></span>
<span><span class="va">seq_p</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, by<span class="op">=</span><span class="fl">0.001</span><span class="op">)</span>;</span>
<span><span class="va">w0</span> <span class="op">=</span> <span class="fl">0</span>; <span class="va">w1</span> <span class="op">=</span> <span class="fl">0</span>;</span>
<span><span class="va">sigma_V2</span> <span class="op">=</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="fl">2</span><span class="op">*</span><span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="co"># = var(V); var(data$V)</span></span>
<span><span class="va">covU0V</span> <span class="op">=</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="co"># = cov(data$U0, data$V)</span></span>
<span><span class="va">covU1V</span> <span class="op">=</span> <span class="op">-</span><span class="va">param_error</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_error</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span> <span class="co"># = cov(data$U1, data$V)</span></span>
<span><span class="va">ku0</span> <span class="op">=</span> <span class="va">covU0V</span><span class="op">/</span><span class="va">sigma_V2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="va">seq_p</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">sigma_V2</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0</span><span class="op">)</span> <span class="co"># 0 = mean(V)</span></span>
<span><span class="va">ku1</span> <span class="op">=</span> <span class="va">covU1V</span><span class="op">/</span><span class="va">sigma_V2</span><span class="op">*</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">qnorm</a></span><span class="op">(</span><span class="va">seq_p</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">sigma_V2</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0</span><span class="op">)</span> <span class="co"># 0 = mean(V)</span></span>
<span><span class="va">true_mtr0</span> <span class="op">=</span> <span class="va">param_y0</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_y0</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="va">w0</span> <span class="op">+</span> <span class="va">ku0</span></span>
<span><span class="va">true_mtr1</span> <span class="op">=</span> <span class="va">param_y1</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">param_y1</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="va">w1</span> <span class="op">+</span> <span class="va">ku1</span></span>
<span><span class="va">true_mte</span> <span class="op">=</span> <span class="va">true_mtr1</span> <span class="op">-</span> <span class="va">true_mtr0</span></span>
<span></span>
<span><span class="va">newdata</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>Ud<span class="op">=</span><span class="va">seq_p</span>, w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">newdata</span><span class="op">$</span><span class="va">true_mte</span> <span class="op">=</span> <span class="va">true_mte</span>; <span class="va">newdata</span><span class="op">$</span><span class="va">true_mtr1</span> <span class="op">=</span> <span class="va">true_mtr1</span>; <span class="va">newdata</span><span class="op">$</span><span class="va">true_mtr0</span> <span class="op">=</span> <span class="va">true_mtr0</span></span>
<span></span>
<span></span>
<span><span class="co">## # Remark: alternative estimation method if the truth does not have a simple closed form formula:</span></span>
<span><span class="co">## data$diff = data$y1 - data$y0; pol_degree=5</span></span>
<span><span class="co">## true_model_mte = lm(diff~w1 + w0 + poly(Ud, pol_degree, raw=TRUE), data); # MTE</span></span>
<span><span class="co">## true_model_mtr1 = lm(y1 ~w1+poly(Ud, pol_degree, raw=TRUE), data) # MTR1</span></span>
<span><span class="co">## true_model_mtr0 = lm(y0 ~w0+poly(Ud, pol_degree, raw=TRUE), data) # MTR0</span></span>
<span><span class="co">## newdata$true_mte = predict(true_model_mte, newdata); </span></span>
<span><span class="co">## newdata$true_mtr1 = predict(true_model_mtr1, newdata); newdata$true_mtr0 = predict(true_model_mtr0, newdata)</span></span>
<span></span>
<span></span>
<span><span class="co"># Comparison:</span></span>
<span><span class="va">mte_plot2</span> <span class="op">=</span> <span class="va">mte_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mte</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"red"</span><span class="op">)</span></span>
<span><span class="va">mtr_plot2</span> <span class="op">=</span> <span class="va">mtr_plot2</span> <span class="op">+</span> <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mtr1</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"blue"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span>data<span class="op">=</span><span class="va">newdata</span>, <span class="fu">aes</span><span class="op">(</span>x<span class="op">=</span><span class="va">Ud</span>, y<span class="op">=</span><span class="va">true_mtr0</span><span class="op">)</span>, linetype<span class="op">=</span><span class="st">"dashed"</span>, col<span class="op">=</span><span class="st">"orange"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mte_plot2</span>, <span class="va">mtr_plot2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mte_true-1.png" width="672" style="display: block; margin: auto;"></p>
<p>Overall, we see that on the common support, the MTE are very
precisely estimated here. What is remarkable is that we do not exploit
the parametric knowledge of the underlying distribution of the shocks at
all.</p>
<p>Compared to the homogenous treatment effect models, the estimation
with heterogenous treatment effects requires more observations.
Otherwise, the MTE are not well estimated at the tails of the common
support. A solution is just to trim the estimation on the set on which
the parameters are well identified then.</p>
</div>
<div class="section level2">
<h2 id="other-options">Other options<a class="anchor" aria-label="anchor" href="#other-options"></a>
</h2>
<p><strong>Trimming the Support.</strong></p>
<p>These seems relatively well estimated, except at the tails where the
common support is not entirely satisfied, while the MTE is only
identified on the common support. If one wants to restrict the
estimation to a given common support, it is very easy to do in
<code><a href="../reference/semiivreg.html">semiivreg()</a></code>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">semiiv1</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiivreg</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">d</span><span class="op">|</span><span class="va">w0</span><span class="op">|</span><span class="va">w1</span>, <span class="va">data</span>, </span>
<span>                    ref_indiv <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fl">0</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span>, </span>
<span>                    common_supp_trim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.10</span>, <span class="fl">0.90</span><span class="op">)</span>,</span>
<span>                    plotting<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot().</span></span>
<span><span class="va">mte_plot</span> <span class="op">=</span> <span class="va">semiiv1</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mte</span>; <span class="va">mtr_plot</span> <span class="op">=</span> <span class="va">semiiv1</span><span class="op">$</span><span class="va">plot</span><span class="op">$</span><span class="va">mtr</span>;</span>
<span><span class="fu">grid.arrange</span><span class="op">(</span><span class="va">mtr_plot</span>, <span class="va">mte_plot</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="semiIVreg_heterogenousTE_files/figure-html/mte_trim1-1.png" width="672" style="display: block; margin: auto;"></p>
<p><strong>Post-estimation prediction.</strong></p>
<p>Imagine after estimating one wants to estimate the model for several
individuals. One way is to directly specify several ref_indiv when
running the initial regression. But if it’s already estimated, one can
simply use the <code>semiiv_predict</code> function. It also allows to
predict only at a subset of specific values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">newdata</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>w0<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, by<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span>, w1<span class="op">=</span><span class="fl">0</span><span class="op">)</span> <span class="co"># Predict the outcome</span></span>
<span></span>
<span><span class="va">pred</span> <span class="op">=</span> <span class="fu"><a href="../reference/semiivreg.html">semiiv_predict</a></span><span class="op">(</span><span class="va">semiiv1</span>, newdata<span class="op">=</span><span class="va">newdata</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pred</span><span class="op">$</span><span class="va">est</span><span class="op">)</span> <span class="co"># the predicted values; -&gt; can then be used to redo plots for example. </span></span>
<span><span class="co">#&gt;     w0 w1 id  Phat     mtr0     mtr1      mte     mte2 mtr0_lwr mtr0_upr</span></span>
<span><span class="co">#&gt; 1   -1  0  1 0.100       NA       NA       NA       NA       NA       NA</span></span>
<span><span class="co">#&gt; 1.1 -1  0  1 0.101 1.912715       NA       NA 2.213390 1.494762 2.330669</span></span>
<span><span class="co">#&gt; 1.2 -1  0  1 0.102 1.913002 4.137639 2.224637 2.211793 1.498057 2.327946</span></span>
<span><span class="co">#&gt; 1.3 -1  0  1 0.103 1.913288 4.136595 2.223306 2.210195 1.501353 2.325224</span></span>
<span><span class="co">#&gt; 1.4 -1  0  1 0.104 1.913575 4.135551 2.221976 2.208598 1.504648 2.322502</span></span>
<span><span class="co">#&gt; 1.5 -1  0  1 0.105 1.913901 4.134507 2.220606 2.206981 1.507910 2.319893</span></span>
<span><span class="co">#&gt;     mtr1_lwr mtr1_upr mte2_lwr mte2_upr       k0       k1   deltak   delta0X</span></span>
<span><span class="co">#&gt; 1         NA       NA       NA       NA       NA       NA       NA -1.001563</span></span>
<span><span class="co">#&gt; 1.1       NA       NA 1.789696 2.637084 2.914278       NA 1.211827 -1.001563</span></span>
<span><span class="co">#&gt; 1.2 3.963550 4.311727 1.791001 2.632585 2.914565 4.137639 1.210230 -1.001563</span></span>
<span><span class="co">#&gt; 1.3 3.963395 4.309794 1.792306 2.628085 2.914852 4.136595 1.208632 -1.001563</span></span>
<span><span class="co">#&gt; 1.4 3.963240 4.307861 1.793610 2.623586 2.915138 4.135551 1.207035 -1.001563</span></span>
<span><span class="co">#&gt; 1.5 3.963085 4.305928 1.794824 2.619139 2.915465 4.134507 1.205418 -1.001563</span></span>
<span><span class="co">#&gt;     delta1X     se_k0      se_k1 se_deltak  se_delta0X se_delta1X</span></span>
<span><span class="co">#&gt; 1         0        NA         NA        NA 0.009050053          0</span></span>
<span><span class="co">#&gt; 1.1       0 0.2132349         NA 0.2161686 0.009050053          0</span></span>
<span><span class="co">#&gt; 1.2       0 0.2116998 0.08881748 0.2146880 0.009050053          0</span></span>
<span><span class="co">#&gt; 1.3       0 0.2101647 0.08836390 0.2132074 0.009050053          0</span></span>
<span><span class="co">#&gt; 1.4       0 0.2086296 0.08791032 0.2117268 0.009050053          0</span></span>
<span><span class="co">#&gt; 1.5       0 0.2071320 0.08745674 0.2102828 0.009050053          0</span></span>
<span><span class="va">pred</span><span class="op">$</span><span class="va">deltaX</span> <span class="co"># provides the shift in effect of X and Wd -&gt; may be the only thing we care about, know that shifts the curve</span></span>
<span><span class="co">#&gt;     w0 w1 id    delta0X delta1X  se_delta0X se_delta1X</span></span>
<span><span class="co">#&gt; 1 -1.0  0  1 -1.0015633       0 0.009050053          0</span></span>
<span><span class="co">#&gt; 2 -0.5  0  2 -0.5007816       0 0.004525027          0</span></span>
<span><span class="co">#&gt; 3  0.0  0  3  0.0000000       0 0.000000000          0</span></span>
<span><span class="co">#&gt; 4  0.5  0  4  0.5007816       0 0.004525027          0</span></span>
<span><span class="co">#&gt; 5  1.0  0  5  1.0015633       0 0.009050053          0</span></span></code></pre></div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-bruneel2024" class="csl-entry">
Bruneel-Zupanc, Christophe. 2024. <span>“Don’t (Fully) Exclude Me, It’s
Not Necessary! Identification with Semi-IVs.”</span> <a href="https://arxiv.org/abs/2303.12667" class="external-link">https://arxiv.org/abs/2303.12667</a>.
</div>
<div id="ref-nprobust" class="csl-entry">
Calonico, Sebastian, Matias D. Cattaneo, and Max H. Farrell. 2019.
<span>“Nprobust: Nonparametric Kernel-Based Estimation and Robust
Bias-Corrected Inference.”</span> <em>Journal of Statistical
Software</em> 91 (8): 1–33. <a href="https://doi.org/10.18637/jss.v091.i08" class="external-link">https://doi.org/10.18637/jss.v091.i08</a>.
</div>
<div id="ref-fangijbels2003" class="csl-entry">
Fan, Jianqing., and Irène. Gijbels. 1996. <em>Local Polynomial Modelling
and Its Applications.</em> Monographs on Statistics and Applied
Probability 66. Boca Raton: Chapman; Hall/CRC.
</div>
<div id="ref-heckman2006understanding" class="csl-entry">
Heckman, James J, Sergio Urzua, and Edward Vytlacil. 2006.
<span>“Understanding Instrumental Variables in Models with Essential
Heterogeneity.”</span> <em>The Review of Economics and Statistics</em>
88 (3): 389–432.
</div>
<div id="ref-heckmanvytlacil2007b" class="csl-entry">
Heckman, James J., and Edward J. Vytlacil. 2007. <span>“Chapter 71
Econometric Evaluation of Social Programs, Part II: Using the Marginal
Treatment Effect to Organize Alternative Econometric Estimators to
Evaluate Social Programs, and to Forecast Their Effects in New
Environments.”</span> In, edited by James J. Heckman and Edward E.
Leamer, 6:4875–5143. Handbook of Econometrics. Elsevier.
https://doi.org/<a href="https://doi.org/10.1016/S1573-4412(07)06071-0" class="external-link">https://doi.org/10.1016/S1573-4412(07)06071-0</a>.
</div>
<div id="ref-robinson1988root" class="csl-entry">
Robinson, Peter M. 1988. <span>“Root-n-Consistent Semiparametric
Regression.”</span> <em>Econometrica: Journal of the Econometric
Society</em>, 931–54.
</div>
<div id="ref-wand1994kernel" class="csl-entry">
Wand, Matt P, and M Chris Jones. 1994. <em>Kernel Smoothing</em>. CRC
press.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Christophe Bruneel-Zupanc.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
