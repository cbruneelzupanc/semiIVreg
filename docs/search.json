[{"path":"https://cbruneelzupanc.github.io/semiIVreg/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 semiIVreg authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVpaper_heterogenous.html","id":"general-model-with-heterogenous-treatment-effects","dir":"Articles","previous_headings":"","what":"General Model with Heterogenous Treatment Effects","title":"Replication, Estimator Performance: homogenous treatment effect model","text":"finish","code":"# 0. Model Specification # ---------------------- N_MC = 50; # number of monte carlo N = 10000; # Number of observations per MC simulations  set.seed(1234)  # Specification model_type = \"heterogenous\" param_error = c(1, 1.5, 0.5, 1.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1, 0.8, 0.3) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(-0.2, -1.2, 1, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 1, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 1.3, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  # Underlying true MTE and MTR: seq_p = seq(0, 1, by=0.001); w0 = 0; w1 = 0; sigma_V2 = param_error[1] + param_error[2] - 2*param_error[3] + param_error[4] # = var(V); var(data$V) covU0V = param_error[1] - param_error[3] # = cov(data$U0, data$V) covU1V = -param_error[2] + param_error[3] # = cov(data$U1, data$V) ku0 = covU0V/sigma_V2*(qnorm(seq_p, mean=0, sd=sqrt(sigma_V2)) - 0) # 0 = mean(V) ku1 = covU1V/sigma_V2*(qnorm(seq_p, mean=0, sd=sqrt(sigma_V2)) - 0) # 0 = mean(V) true_mtr0 = param_y0[1] + param_y0[2]*w0 + ku0 true_mtr1 = param_y1[1] + param_y1[2]*w1 + ku1 true_mte = true_mtr1 - true_mtr0 newdata = data.frame(Ud=seq_p, w0=0, w1=0) newdata$true_mte = true_mte; newdata$true_mtr1 = true_mtr1; newdata$true_mtr0 = true_mtr0"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVpaper_homogenous.html","id":"monte-carlo-simulation-functions-for-model-with-homogenous-te","dir":"Articles","previous_headings":"","what":"Monte Carlo Simulation functions for model with Homogenous TE","title":"Replication, Estimator Performance: homogenous treatment effect model","text":"","code":"# ---------------------------------- # 1. Monte-Carlo Simulation function # ---------------------------------- MC_fun = function(N_simul, N, param) {    param_error = param[[1]];   param_Z = param[[2]];   param_p = param[[3]]; param_y0 = param[[4]]; param_y1 = param[[5]]   param_genX = param[[6]];   model_type = param[[7]]    # 1. Monte Carlo Simulation   RES = list(); MTR = list(); MTRh = list()   k=1    while(k <= N_simul) {     # Simulate:     data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)      # i) Naive OLS:     naive_ols = lm(y ~ d + I((1-d)*w0) + I(d*w1), data); #summary(naive_ols)     ols_est = naive_ols$coefficients      # ii) Semi-IV 2SLS     fstage = lm(d~w0+w1, data); summary(fstage)     data$Phat = fitted(fstage)     semiiv2sls = lm(y ~ Phat + I((1-Phat)*w0) + I(Phat*w1), data); #summary(semiiv2sls)     semiiv2sls_est = semiiv2sls$coefficients      # iii) Semi-IV 2SLS-bis - probit fstage     fstage = glm(d~w0+w1, family=binomial(link=\"probit\"), data=data)     data$Phat = fitted(fstage)     semiiv2sls_probit = lm(y ~ Phat + I((1-Phat)*w0) + I(Phat*w1), data); #summary(semiiv2sls)     semiiv2sls_est_probit = semiiv2sls_probit$coefficients      # iv) Semi-IV general     semiiv = semiivreg(y ~ d | w0 | w1, ref_indiv = data.frame(w0=0, w1=0), data=data,                        trimming_value = c(0.01, 0.99),                        bw0 = 0.1, bw1=0.1, bw_y0=0.1, bw_y1=0.1,                        fast_robinson2 = TRUE, plotting=FALSE)     EY0 = mean(semiiv$data$RES$mtr0, na.rm=TRUE); EY1 = mean(semiiv$data$RES$mtr1, na.rm=TRUE); ATE = mean(semiiv$data$RES$mte, na.rm=TRUE)     semiiv_est = c(EY0, ATE, semiiv$estimate$est0$coefficients, semiiv$estimate$est1$coefficients)     MTR[[k]] = semiiv$data$RES;      # v) Semi-IV homogenous:     semiivh = semiivreg(y ~ d | w0 | w1, ref_indiv = data.frame(w0=0, w1=0), data=data, est_method=\"homogenous\", plotting=FALSE)     semiivh_est = semiivh$estimate$est[1:4, 2]     MTRh[[k]] = semiivh$data$RES      # vi) IVreg:     iv = ivreg(y~d|w0+w1, data=data); #summary(iv)     iv_est = c(iv$coefficients, NA, NA)      # Save:     save = rbind(ols_est, iv_est, semiiv2sls_est, semiiv2sls_est_probit, semiiv_est, semiivh_est)     save = data.frame(save); names(save) = c(\"mu0\", \"mu1mu0\", \"delta0\", \"delta1\")     save$k = k     save$method = c(\"ols\", \"iv\", \"semi2sls\", \"semiiv2sls_probit\", \"semiiv\", \"semiivh\")      RES[[k]] = save      k = k+1;     if(k%%10 == 0) { print(k)}   }     res_mc = do.call(rbind, RES);   MTR = do.call(rbind, MTR)   MTRh = do.call(rbind, MTRh)   res = list(res_mc, MTR, MTRh)   return(res) }"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVpaper_homogenous.html","id":"specification-1","dir":"Articles","previous_headings":"Baseline model with semi-IVs","what":"Specification 1","title":"Replication, Estimator Performance: homogenous treatment effect model","text":"Adjust Number observations (N) Number Monte Carlo simulations (N_simul) accordingly. Results estimation. Specification 1 Table Online Appendix Plot. Corresponding estimated MTRs:","code":"# ------------------------------------------------ # 2. Simulations with homogenous Treatment Effects - Baseline Model # ------------------------------------------------ # Remark: param_genX are irrelevant in all simulations because I set the coefficients such that the covariates have no effect on anything; N = 10000; N_simul=50;  # (i) Model model_type = \"homogenous\" param_error = c(1, 1, 0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1, 1, 0.5) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous) # Remark: mean_V and the constant in the probit are playing the same role; normalize one to zero. param = list(param_error, param_Z, param_p, param_y0, param_y1, param_genX, model_type)  # (ii) Monte Carlo: res = MC_fun(N_simul, N, param) #> [1] 10 #> [1] 20 #> [1] 30 #> [1] 40 #> [1] 50 res_mc = res[[1]]; MTR = res[[2]]; MTRh = res[[3]] # (iii) Table of coefficients # Table: dmc = data.table(res_mc); dmc[, list(mean_mu0=mean(mu0), sd_mu0=sd(mu0), mean_mu1mu0=mean(mu1mu0), sd_mu1mu0=sd(mu1mu0),            mean_delta0=mean(delta0), sd_delta0=sd(delta0), mean_delta1=mean(delta1), sd_delta1=sd(delta1)), by=method] #>               method mean_mu0     sd_mu0 mean_mu1mu0  sd_mu1mu0 mean_delta0 #>               <char>    <num>      <num>       <num>      <num>       <num> #> 1:               ols 3.609778 0.01394536 -0.41968256 0.01892358   0.7050172 #> 2:                iv 3.516927 0.04262833  0.06117361 0.07239250          NA #> 3:          semi2sls 3.211819 0.03713813  0.38330306 0.07321947   0.7800737 #> 4: semiiv2sls_probit 3.206479 0.03392688  0.38796892 0.06593859   0.7953671 #> 5:            semiiv 3.204777 0.10396056  0.40636901 0.14197412   0.8012196 #> 6:           semiivh 3.201246 0.02728690  0.39843035 0.05054166   0.7987917 #>     sd_delta0 mean_delta1  sd_delta1 #>         <num>       <num>      <num> #> 1: 0.01358256   0.5915442 0.01376828 #> 2:         NA          NA         NA #> 3: 0.02759336   0.4909378 0.02959361 #> 4: 0.02708549   0.5018265 0.02870017 #> 5: 0.01608017   0.4980638 0.01734865 #> 6: 0.01445555   0.4980844 0.01667331 # (iv) Plot MTR # a) Compute the true MTR: seq_p = seq(0, 1, by=0.001); w0 = 0; w1 = 0; sigma_V2 = param_error[2] covUV = param_error[3] ku0 = covUV/sigma_V2*(qnorm(seq_p, mean=0, sd=sqrt(sigma_V2)) - 0) # 0 = mean(V) ku1 = ku0 # 0 = mean(V) true_mtr0 = param_y0[1] + param_y0[2]*w0 + ku0 true_mtr1 = param_y1[1] + param_y1[2]*w1 + ku1 true_mte = true_mtr1 - true_mtr0  newdata = data.frame(Ud=seq_p, w0=0, w1=0) newdata$true_mte = true_mte; newdata$true_mtr1 = true_mtr1; newdata$true_mtr0 = true_mtr0   # b) MTR plot: # Graphical options:   colMTE = \"#db93a4\"; colD0 = \"#f7ba4a\"; colD1 = \"#9993db\" colMTEtrue = \"#DE40AA\"; colD0true = \"#EE7000\"; colD1true = \"#663A96\"  dat = data.table(MTRh);  conf_level = 0.05  CI = dat[, .(   count0 = sum(!is.na(mtr0)),   count1 = sum(!is.na(mtr1)),   count_mte = sum(!is.na(mte)),   mte = mean(mte, na.rm=TRUE),   mte_lwr = quantile(mte, conf_level/2, na.rm=TRUE),   mte_upr = quantile(mte, 1-conf_level/2, na.rm=TRUE),   mtr0 = mean(mtr0, na.rm=TRUE),   mtr0_lwr = quantile(mtr0, conf_level/2, na.rm=TRUE),   mtr0_upr = quantile(mtr0, 1-conf_level/2, na.rm=TRUE),   mtr1 = mean(mtr1, na.rm=TRUE),   mtr1_lwr = quantile(mtr1, conf_level/2, na.rm=TRUE),   mtr1_upr = quantile(mtr1, 1-conf_level/2, na.rm=TRUE) ), by = .(Phat, id)]  RES_plot = CI;  common_supp_plot = c(0, 1) mtr_plot = mtr_plot_fun(RES_plot, common_supp_plot, conf_band=TRUE) mtr_p = mtr_plot +   geom_line(data=newdata, aes(x=Ud, y=true_mtr0), color=colD0true, linetype=\"dashed\") +   geom_line(data=newdata, aes(x=Ud, y=true_mtr1), color=colD1true, linetype=\"dashed\") mtr_p = mtr_p + theme_classic() +   theme(     legend.text = element_text(size = 11), # if needs rescaling     legend.position = c(0.97, 0),     legend.justification = c(\"right\", \"bottom\"), #, # Align the legend's bottom-left corner     legend.background = element_blank()   ) +   scale_color_manual(values = c(\"0\" = \"#f7ba4a\", \"1\" = \"#9993db\"), labels = c(\"0\" = \"d=0\", \"1\" = \"d=1\")) +   scale_fill_manual(values = c(\"0\" = \"#f7ba4a\", \"1\" = \"#9993db\"), labels = c(\"0\" = \"d=0\", \"1\" = \"d=1\")) +   labs(color = NULL, fill = NULL) +   ylab(bquote(\"Marginal Treatment Responses \" ~ (MTR[d]))) +   xlab(\"Unobserved resistance to treatment, V\") +   scale_x_continuous(limits = c(0, 1), expand = expand_scale(add = c(0, 0.02))) #+ #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. #> Scale for x is already present. #> Adding another scale for x, which will replace the existing scale. #ylim(2.5, 4.6) mtr_p"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVpaper_homogenous.html","id":"specification-2-what-if-the-semi-ivs-are-valid-ivs","dir":"Articles","previous_headings":"Baseline model with semi-IVs","what":"Specification 2: What if the semi-IVs are valid IVs?","title":"Replication, Estimator Performance: homogenous treatment effect model","text":"Just change effect semi-IVs respective potential outcomes zero, rerun previous code.","code":"param_y0 = c(3.2, 0, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param = list(param_error, param_Z, param_p, param_y0, param_y1, param_genX, model_type)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"semiIVreg: R package for semi-IV regression","text":"package provides estimation procedure semi-IVs, Bruneel-Zupanc (2024). particular, main function semiivreg() estimates marginal treatment effect (MTE) marginal treatment response (MTR).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"semiIVreg: R package for semi-IV regression","text":"development version semiIVreg hosted GitHub . can conveniently installed via install_github() function remotes package.","code":"remotes::install_github(\"cbruneelzupanc/semiIVreg\")"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"semiIVreg: R package for semi-IV regression","text":"semiivreg estimates marginal treatment effect (MTE) marginal treatment response (MTR) following model. potential outcomes given semi-parametric model: Y0=Œ¥0+W0Œ≤0+XŒ≤0X+U0,(1) Y_0 = \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + U_0, \\quad \\quad \\quad (1) Y1=Œ¥1+W1Œ≤1+XŒ≤1X+U1,(2) Y_1 = \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + U_1, \\quad \\quad \\quad (2) selection rule D*=g(W0,W1,X)‚àíV=(Œ±+Œ±0W0+Œ±1W1+Œ±XX)‚àíV,(3) D=ùïÄ(D*>0), \\begin{aligned} D^* &= g(W_0, W_1, X) - V \\\\ &= (\\alpha + \\alpha_0 W_0 + \\alpha_1 W_1 + \\alpha_{X} X ) - V, \\quad \\quad \\quad (3) \\\\ \\text{ } \\quad D &= \\mathbb{}(D^* > 0), \\end{aligned} semi-IVs: W0W_0 (respectively W1W_1) semi-IVs excluded Y1Y_1 (resp. Y0Y_0). W0W_0 W1W_1 may contain several variables. Nonparametric identification requires WdW_d contains least one excluded variable (see Bruneel-Zupanc (2024)). Covariates: XX covariates affect potential outcomes. default, different effect covariates across alternatives, (.e., Œ≤0X‚â†Œ≤1X\\beta^X_{0} \\neq \\beta^X_{1}). , include covariates separately MTR formulas: semiivreg(y~d|w0+x|w1+x, data). One can restrict effect XX across potential outcomes (.e., Œ≤0X=Œ≤1X\\beta^X_{0} = \\beta^X_{1}). , specify: semiivreg(y~d|w0|w1|x, data). Unobservables: U0U_0 U1U_1 general unobservables (may include several shocks, may across alternatives) affecting outcomes. Generally normalize E(Ud|X,Wd)=0E(U_d | X, W_d)=0. VV scalar unobservable affects selection. lower VV, likely one select treatment. Nonparametric identification requires independence, .e., (U0,U1,V)‚ä•(W0,W1)|X(U_0, U_1, V) \\perp (W_0, W_1) | X. estimation , additionally assume additive separability covariates XX, .e., E(Ud|V,X)=E(Ud|V)E(U_d | V, X) = E(U_d | V) d=0,1d=0,1. assumption necessary identification, estimation. standard simplification helps estimation. See Carneiro, Heckman, Vytlacil (2011), Brinch, Mogstad, Wiswall (2017) Andresen (2018) comparable examples estimation MTE IVs. Remark flexibility model: note W0W_0 W1W_1 can flexible transformations (polynomial, splines) specific variables, outcome equations quite flexible (also specify interactions WdW_d XX). semi-parametric model main assumption separability unobservables X,WdX, W_d, otherwise model general can .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"estimation-procedure","dir":"Articles","previous_headings":"","what":"Estimation procedure","title":"semiIVreg: R package for semi-IV regression","text":"estimation procedure closely follows counterpart estimation MTE standard IVs, see e.g., Andresen (2018). command estimates Marginal Treatment Responses (MTR) Marginal Treatment Effects (MTE). Define normalized unobserved resistance treatment UD=FV(V)‚àºUniform(0,1)U_D = F_V(V) \\sim Uniform(0, 1). , MTRs given : MTRd(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=Œ¥d+WdŒ≤d+XŒ≤dX+E(Ud|X=x,Wd=wd,UD=u)=Œ¥d+WdŒ≤d+XŒ≤dX+E(Ud|UD=u)=Œ¥d+WdŒ≤d+XŒ≤dX+kd(u), \\begin{aligned} MTR_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + E(U_d|X=x, W_d=w_d, U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + E(U_d|U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + k_d(u), \\end{aligned}  last equalities comes fact E(Ud|X=x,Wd=wd,UD=u)=E(Ud|UD=u)E(U_d|X=x, W_d=w_d, U_D=u) = E(U_d|U_D=u) separability independence, just define kd(u)=E(Ud|UD=u)k_d(u) = E(U_d|U_D=u). , Marginal Treatment Effects (MTE) given MTE(u,x,w0,w1)=E(Y1‚àíY0|X=x,W0=w0,W1=w1,UD=u)=MTR1(u,w1,x)‚àíMTR0(u,w0,x). \\begin{aligned} MTE(u, x, w_0, w_1) &= E(Y_1 - Y_0 | X = x, W_0=w_0, W_1=w_1, U_D=u) \\\\ &= MTR_1(u, w_1, x) - MTR_0(u, w_0, x). \\end{aligned} Remark: MTR MTE estimated given covariates semi-IVs, (X,W0,W1)(X, W_0, W_1). specified using ref_indiv. default, computes ‚Äòaverage individual‚Äô (take reference level factor). estimation proceeds two stages: first estimate propensity treated, PP, potential outcome treatment parameters.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"st-stage-propensity-score","dir":"Articles","previous_headings":"Estimation procedure","what":"1st stage: propensity score","title":"semiIVreg: R package for semi-IV regression","text":"Estimate propensity score PÃÇ\\widehat{P} treatment selection equation (3). default, function g(‚ãÖ)g(\\cdot) given simple linear specification , code allows specifying first stage. example: default, estimation assumes probit model first stage (.e., assumes VV normally distributed). However, can specify models (e.g., logit) using firststage_model argument. theory, specification first stage added, even possible estimate propensity score outside semiivreg command (feature implemented yet).","code":"semiivreg(y~d|w0+x|w1+x, data,             propensity_formula = d~w0+w1+w0:w1+w0:x+w1:x+I(w0^2)+I(w1^2))"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"estimated-objects","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Estimated objects","title":"semiIVreg: R package for semi-IV regression","text":"First, given estimated PÃÇ\\widehat{P}, second stage estimates following semi-parametric partially linear model potential outcomes E[Y|D=0,W0,X,PÃÇ]=Œ¥0+W0Œ≤0+XŒ≤0X+Œ∫0(PÃÇ),E[Y|D=1,W1,X,PÃÇ]=Œ¥1+W1Œ≤1+XŒ≤1X+Œ∫1(PÃÇ), \\begin{aligned} E[Y|D=0, W_0, X, \\widehat{P}] &= \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + \\kappa_0(\\widehat{P}), \\\\ E[Y|D=1, W_1, X, \\widehat{P}] &= \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + \\kappa_1(\\widehat{P}),  \\end{aligned}  Œ∫d(P)\\kappa_d(P) control functions, equal Œ∫1(P)=E[U1|D=1,W1,W0,X,P]=E[U1|D=1,P]=E[U1|UD‚â§P]Œ∫0(P)=E[U0|D=0,W1,W0,X,P]=E[U0|D=0,P]=E[U0|UD>P]. \\begin{aligned} \\kappa_1(P) &= E[ U_1 | D=1, W_1, W_0, X,P] = E[U_1|D=1, P] = E[U_1 | U_D \\leq P] \\\\ \\kappa_0(P) &= E[ U_0 | D=0, W_1, W_0, X,P] = E[U_0|D=0, P] = E[U_0 | U_D > P]. \\end{aligned}  partially linear model control functions nonparametric can estimated less flexibly (see ). parameters Œ¥d,Œ≤d,Œ≤dX\\delta_d, \\beta_d, \\beta^X_d flexible control function Œ∫d()\\kappa_d() estimated, don‚Äôt need estimate parameters obtain MTE MTR. need also obtain derivative estimated Œ∫d\\kappa_d. Indeed, define kÃÇ1(u)=E[U1|UD=u]=Œ∫ÃÇ1(u)+uŒ∫ÃÇ1‚Ä≤(u),kÃÇ0(u)=E[U0|UD=u]=Œ∫ÃÇ0(u)‚àí(1‚àíu)Œ∫ÃÇ0‚Ä≤(u). \\begin{aligned} \\widehat{k}_1(u) &= E[ U_1 | U_D=u] = \\widehat{\\kappa}_1(u) + u \\widehat{\\kappa}_1'(u), \\\\ \\widehat{k}_0(u) &= E[ U_0 | U_D=u] = \\widehat{\\kappa}_0(u) - (1-u) \\widehat{\\kappa}_0'(u). \\end{aligned} , Marginal Treatment Responses given : MTRÃÇd(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=Œ¥ÃÇd+wdŒ≤ÃÇd+xŒ≤ÃÇdX+kÃÇd(u) \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = \\widehat{\\delta}_{d} + w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{k}_d(u) \\end{aligned} Marginal Treatment Effects : MTEÃÇ(u,x,w0,w1)=MTRÃÇ1(u,w1,x)‚àíMTRÃÇ0(u,w0,x). \\begin{aligned} \\widehat{MTE}(u, x, w_0, w_1) = \\widehat{MTR}_1(u, w_1, x) - \\widehat{MTR}_0(u, w_0, x). \\end{aligned} Consequently, estimation estimating parameters Œ∫d\\kappa_d. Several estimation method est_method implemented semiivreg(). describe .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-1--double-residual-regression-robinson-1988","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 1. Double residual regression, Robinson (1988)","title":"semiIVreg: R package for semi-IV regression","text":"default method, implemented est_method=\"locpoly\" run double residual regression, √† la Robinson (1988), order estimate partially linear model. implement similarly separate approach Andresen (2018) estimation MTE IVs. estimate using separate approach, .e., estimate separately treated untreated samples, implementing following steps: Step 1. Estimate E(Yd|D=d,PÃÇ)E(Y_d | D=d, \\widehat{P}), E(Wd|D=d,PÃÇ)E(W_d | D=d, \\widehat{P}) E(X|D=d,PÃÇ)E(X | D=d, \\widehat{P}) nonparametric local polynomial regression. specify bandwidth local polynomial regression, use bw0 bw1. specified, bandwidth automatically computed using method bw_method. default fast \"1/5 rule, picking bandwidth equal 1/5th common support. can also specify degree polynomial pol_degree_locpoly1. default, equal 11 recommended Fan Gijbels (1996) (order function target +1+1). Step 2. subsample, compute residuals eYd=Yd‚àíE(Yd|D=d,PÃÇ)e_{Y_d} = Y_d - E(Y_d | D=d, \\widehat{P}), eWd=Wd‚àíE(Wd|D=d,PÃÇ)e_{W_d} = W_d - E(W_d | D=d, \\widehat{P}) eXd=X‚àíE(X|D=d,PÃÇ)e_X^d = X - E(X | D=d, \\widehat{P}). , run first residual regression, -intercept OLS:eYd=eWdŒ≤d+eXdŒ≤dX+UÃÉd. e_{Y_d} = e_{W_d} \\beta_d + e_X^d \\beta^X_d + \\tilde{U}_d.  regression subsample D=dD=d, provides consistent estimates Œ≤d\\beta_d Œ≤dX\\beta^X_d. Indeed, residual equation equivalent toYd‚àíE[Yd|D=d,PÃÇ]=(Wd‚àíE[Wd|D=d,PÃÇ])Œ≤d+E(X‚àíE[X|D=d,PÃÇ])Œ≤dX+(Ud‚àíE[Ud|D=d,PÃÇ]). Y_d - E[Y_d | D=d, \\widehat{P}] = (W_d - E[W_d | D=d, \\widehat{P}]) \\beta_d + E(X - E[X | D=d, \\widehat{P}]) \\beta_d^X + (U_d - E[U_d | D=d, \\widehat{P}]).  denote UÃÉd=Ud‚àíE[Ud|D=d,PÃÇ]\\tilde{U}_d = U_d - E[U_d | D=d, \\widehat{P}], E[UÃÉd|D=d,PÃÇ]=0E[\\tilde{U}_d | D=d,  \\widehat{P}] = 0, -intercept residual OLS regression gives consistent estimates. Step 3. Construct YÃÉd=Y‚àíWdŒ≤dÃÇ‚àíXŒ≤dXÃÇ\\tilde{Y}_d = Y - W_d \\widehat{\\beta_d} - X \\widehat{\\beta^X_d}, sample D=dD=d, .e., outcome net effect covariates. YÃÉd=Œ¥d+Ud.\\tilde{Y}_d = \\delta_d + U_d.  yields Œ∫ÃÉd(P)=E[YÃÉd|D=d,P] \\tilde{\\kappa}_d(P) = E[\\tilde{Y}_d | D=d, P] Step 4. Estimate Œ∫ÃÉd(P)\\tilde{\\kappa}_d(P) using second nonparametric local polynomial regression YÃÉd\\tilde{Y}_d PP. specify bandwidth local polynomial regression, use bw_y0 bw_y1. specified, bandwidth automatically computed using method bw_method. default arbitrary 1/5th rule, recommend using \"mse-dpi\" direct plug-MSE optimal bandwidth Fan Gijbels (1996), implemented nprobust package (Calonico, Cattaneo, Farrell (2019)) instead. can also specify degree polynomial pol_degree_locpoly2. default, equal 22 recommended Fan Gijbels (1996) want estimate derivative, kÃÉd(u)=E[Œ¥d+Ud|UD=u]\\tilde{k}_d(u) = E[\\delta_d + U_d|U_D=u]. Œ∫ÃÉd\\tilde{\\kappa}_d, can compute kÃÉÃÇ1(u)=E[Œ¥1+U1|UD=u]=Œ∫ÃÉÃÇ1(u)+uŒ∫ÃÉÃÇ1‚Ä≤(u),kÃÉÃÇ0(u)=E[Œ¥0+U0|UD=u]=Œ∫ÃÉÃÇ0(u)‚àí(1‚àíu)Œ∫ÃÉÃÇ0‚Ä≤(u). \\begin{aligned} \\widehat{\\tilde{k}}_1(u) &= E[ \\delta_1 + U_1 | U_D=u] = \\widehat{\\tilde{\\kappa}}_1(u) + u \\widehat{\\tilde{\\kappa}}_1'(u), \\\\ \\widehat{\\tilde{k}}_0(u) &= E[ \\delta_0 + U_0 | U_D=u] = \\widehat{\\tilde{\\kappa}}_0(u) - (1-u) \\widehat{\\tilde{\\kappa}}_0'(u). \\end{aligned} Using kÃÉÃÇd(u)\\widehat{\\tilde{k}}_d(u) estimated Œ≤ÃÇd,Œ≤ÃÇdX\\widehat{\\beta}_d, \\widehat{\\beta}^X_d, can compute MTR subsample D=dD=d, MTRÃÇd(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=wdŒ≤ÃÇd+xŒ≤ÃÇdX+kÃÉÃÇd(u). \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{\\tilde{k}}_d(u). \\end{aligned}  Remark definition Œ∫ÃÉd(P)\\tilde{\\kappa}_d(P), equivalent defining general shock include constant, UÃÉd=Œ¥d+Ud\\tilde{U}_d = \\delta_d + U_d. innoccuous yield MTR/MTE end. MTR estimated separately subsample, can estimate MTE: MTRÃÇd(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=wdŒ≤ÃÇd+xŒ≤ÃÇdX+kÃÉÃÇd(u)MTEÃÇ(u,x,w0,w1)=MTRÃÇ1(u,w1,x)‚àíMTRÃÇ0(u,w0,x). \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{\\tilde{k}}_d(u) \\\\ \\widehat{MTE}(u, x, w_0, w_1) &= \\widehat{MTR}_1(u, w_1, x) - \\widehat{MTR}_0(u, w_0, x). \\end{aligned} Advantages. main advantage double residual regression robust misspecification nonparametric Œ∫d\\kappa_d function, see Robinson (1988). However, still requires specify bandwidths. order obtain standard errors around estimates, given PP estimated first stage, bootstrap standard errors using semiivreg_boot(). function takes longer default estimation almost instantaneous.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-2--sieve-estimation","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 2. Sieve estimation","title":"semiIVreg: R package for semi-IV regression","text":"alternative method use sieve approach, implemented est_method=\"sieve\", estimate second stage. idea simply specify control function Œ∫d\\kappa_d flexible function PP, using flexible functional form. default use polynomial transformation degree pol_degree_sieve=5 Œ∫0(P)\\kappa_0(P) Œ∫1(P)\\kappa_1(P). , estimate second stage using stacked regression form: E[Y|W0,W1,X,PÃÇ]=D√ó(Œ¥1+W1Œ≤1+XŒ≤1X+Œ∫1(PÃÇ))+(1‚àíD)√ó(Œ¥0+W0Œ≤0+XŒ≤0X+Œ∫0(PÃÇ)). \\begin{aligned} E[Y|W_0, W_1, X, \\widehat{P}] = &D \\times ( \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + \\kappa_1(\\widehat{P}) ) + \\\\ &(1-D) \\times ( \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + \\kappa_0(\\widehat{P})). \\end{aligned}  stacked regression separately order allow restrict covariates effect potential outcomes (e.g., Œ≤0X=Œ≤1X\\beta_0^X = \\beta_1^X). obtain Œ∫ÃÇd(P)\\widehat{\\kappa}_d(P), proceed obtain kd(u)k_d(u) MTR/MTE. polynomial functional form, kd(u)k_d(u) known functional form based estimated coefficients Œ∫d\\kappa_d, easy compute. Advantages. main advantage sieve approach faster easier implement (\"locpoly\" also fast anyway). also provides analytical standard errors. wrong take account PÃÇ\\widehat{P} estimated first stage, , PÃÇ\\widehat{P} well estimated, analytical standard errors close true one can obtain bootstrap semiivreg_boot(). disadvantage less robust misspecification control function polynomial. Even though, visible vignette, still works well examples, even underlying Œ∫d\\kappa_d polynomial.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-3--special-case-with-homogenous-treatment-effects","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 3. Special Case with Homogenous Treatment Effects","title":"semiIVreg: R package for semi-IV regression","text":"Using est_method=\"homogenous\", semiivreg() can also estimate restricted model assume treatment effects homogenous, .e., MTE(u,x,w0,w1)=MTE(x,w0,w1)MTE(u, x, w_0, w_1) = MTE(x, w_0, w_1), varies observable covariates, constant respect UDU_D. homogenous treatment effect assumption equivalent imposing underlying model corresponds general potential outcome model (1)-(2), additional restriction U0=U1=UU_0 = U_1 = U. estimated using procedure similar sieve approach heterogenous treatment effects, impose additional known restriction control functions Œ∫0(P)\\kappa_0(P) Œ∫1(P)\\kappa_1(P) second stage estimation. Indeed, E(U)=0=E(U|UD‚â§P)P+E(U|UD>P)(1‚àíP) E(U) = 0 = E(U | U_D \\leq P) P + E(U | U_D > P) (1-P) , Œ∫0(P)=‚àíŒ∫1(P)P1‚àíP\\kappa_0(P) = -\\kappa_1(P) \\frac{P}{1-P}, one can check yields k0(u)=k1(u)=k(u)k_0(u) = k_1(u) = k(u). Thus, MTE constant (k1(u)‚àík0(u)=0k_1(u) - k_0(u) = 0, cancels ), equal : MTEÃÇ(x,w0,w1)=Œ¥ÃÇ1‚àíŒ¥ÃÇ0+w1Œ≤ÃÇ1‚àíw0Œ≤ÃÇ0+x(Œ≤ÃÇ1X‚àíŒ≤ÃÇ0X). \\widehat{MTE}(x, w_0, w_1) = \\widehat{\\delta}_{1} - \\widehat{\\delta}_{0} + w_1 \\widehat{\\beta}_1 - w_0 \\widehat{\\beta}_0 + x (\\widehat{\\beta}^X_{1} - \\widehat{\\beta}^X_{0}). Note MTR still varies uu k(u)k(u) constant, MTE .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"caution-about-the-estimated-standard-errors","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Caution about the Estimated Standard Errors","title":"semiIVreg: R package for semi-IV regression","text":"default, est_method=\"sieve\" \"homogenous‚Äù return analytic standard errors‚Ä¶ accounting fact propensity score estimated first stage semiivreg. Thus, wrong (bias small first stage well estimated, see simulations example). Use semiivreg_boot obtain ‚Äòcorrect‚Äô bootstrapped confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"illustration-with-simulated-roy-model","dir":"Articles","previous_headings":"","what":"Illustration with simulated Roy model","title":"semiIVreg: R package for semi-IV regression","text":"illustrates semiivreg()command reports semi-IV regression. default, reports common support plot propensity score estimated marginal treatment effects (MTE). default, est_method = \"locpoly\" Robinson (1988) double residual regression using local polynomial regressions.  One can also easily extract plot marginal treatment responses (MTR):  one wants use sieve estimation method, simply run:   One advantage sieve reports confidence interval (though wrong take account first stage error) also gives functional form MTR MTE, obtainable running code . Similarly, homogenous treatment effects also provide functional form estimation. details, see vignettes estimation heterogenous homogenous treatment effects. Refer also Bruneel-Zupanc (2024).","code":"library(semiIVreg) data(roydata) # load the data from a simulated Roy model  # semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata)  #> Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot(). semiiv$plot$mtr # semi-IV sieve regression semiiv = semiivreg(y~d|w0|w1, data=roydata, est_method=\"sieve\") semiiv$plot$mtr semiiv$est$mtr0;  #>      Variable    Estimate    Std_Error      t_value     p_value #> 1 (Intercept)   2.7581424 9.298226e-01   2.96631018 0.003014676 #> 2  kd(v): v^1  -0.6853761 1.229132e+01  -0.05576099 0.955532327 #> 3  kd(v): v^2  12.0175370 5.692871e+01   0.21109801 0.832811220 #> 4  kd(v): v^3 -30.6762292 1.188494e+02  -0.25811010 0.796322466 #> 5  kd(v): v^4  31.3667340 1.142864e+02   0.27445721 0.783733849 #> 6  kd(v): v^5 -10.8461651 4.113650e+01  -0.26366279 0.792040318 #> 7          w0   0.8002338 3.955818e-03 202.29288041 0.000000000 semiiv$est$mtr1;  #>      Variable    Estimate    Std_Error      t_value       p_value #> 1 (Intercept)   4.3655568  0.142511442  30.63302633 3.985092e-205 #> 2  kd(v): v^1  -3.2471062  3.735243561  -0.86931580  3.846765e-01 #> 3  kd(v): v^2   4.2847118 26.418324185   0.16218711  8.711588e-01 #> 4  kd(v): v^3   4.5087919 75.498769743   0.05972007  9.523787e-01 #> 5  kd(v): v^4 -17.9382899 93.543557546  -0.19176403  8.479274e-01 #> 6  kd(v): v^5  11.5530308 41.752329058   0.27670387  7.820081e-01 #> 7          w1   0.4977251  0.003904244 127.48309330  0.000000e+00 semiiv$est$mte #>      Variable    Estimate    Std_Error      t_value    p_value #> 1 (Intercept)   1.6074144 9.406804e-01    1.7087784 0.08749511 #> 2  kd(v): v^1  -2.5617302 1.284634e+01   -0.1994132 0.84193997 #> 3  kd(v): v^2  -7.7328252 6.275990e+01   -0.1232128 0.90193882 #> 4  kd(v): v^3  35.1850210 1.408021e+02    0.2498898 0.80267307 #> 5  kd(v): v^4 -49.3050239 1.476881e+02   -0.3338455 0.73849682 #> 6  kd(v): v^5  22.3991960 5.861287e+01    0.3821549 0.70234729 #> 7    + W1: w1   0.4977251 3.904244e-03  127.4830933 0.00000000 #> 8    - W0: w0  -0.8002338 3.955818e-03 -202.2928804 0.00000000"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"simulate-data","dir":"Articles","previous_headings":"","what":"Simulate data","title":"Estimator Performance: general heterogenous treatment effect model","text":"simulate generalized Roy models using simul_data()function. See documentation function details model. Depending chosen parameters, can simulate model homogenous/heterogenous treatment effects, well valid IVs eventually. ‚Äôs . every simulation include covariates (set effect 0), can easily included.","code":"# Model library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric N = 50000; set.seed(1234) # Specification model_type = \"heterogenous\" param_error = c(1, 1.5, 0.5, 1.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1, 0.8, 0.3) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(-0.2, -1.2, 1, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 1, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 1.3, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"semi-iv-regression","dir":"Articles","previous_headings":"","what":"semi-IV regression","title":"Estimator Performance: general heterogenous treatment effect model","text":"Let us apply directly semiivreg()function. Compute MTE MTR reference individuals average value semi-IVs, .e., (W0,W1)=(0,0)(W_0, W_1) = (0, 0) . Remark: MTE(u,w0,w1,x)MTE(u, w_0, w_1, x) depend XX W0,W1W_0, W_1, always need pick reference individual. default, semiivreg computes average individuals (continuous/binary covariates semi-IVs), takes ‚Äòreference level‚Äô factor variables. terms estimation method, default, semivreg() estimates second-stage local polynomial regression, spirit double residual regression partially linear models Robinson (1988). specified using default est_method=\"locpoly\". estimation advantage robust misspecification control function Œ∫d(u)\\kappa_d(u) functional form.  Let us report also marginal treatment responses (MTR):  Attention: standard errors reported wrong (narrow)! take account fact propensity score estimated. locpoly estimation (default), simply standard errors around kd(v)k_d(v), take account error effect covariates. get proper standard errors, one use bootstrap. options: speed things (especially useful first residual regression), can use fast_robinson1 = TRUE (1st residual regression YY, XX WdW_d PP) fast_robinson2 = TRUE (second residual regression). fast_robinson uses locpoly() function KernSmooth package, much faster default routine implemented. several drawbacks though: () implemented kernel=\"gaussian\", (ii) compute standard errors around kd(v)k_d(v) estimates (anyway, completely correct), (iii) use external weights data. Direct effect semi-IVs. Also estimates effect semi-IV respective potential outcomes. see : Notice standard errors biased take account propensity score estimated. Standard errors. get proper standard errors MTE/MTR effects semi-IVs default \"locpoly\"estimation method, use bootstrap function semiivreg_boot(). takes longer estimate though. Bandwidth Specification. default, est_method=\"locpoly\", bandwidth provided, bandwidth computed using bw_method. default bw_method simplistic: picks bandwidth specified fraction (1/5th) range support (rounded 3rd digit). can set bw_method number (0 1) pick bandwidth function support automatically. One can also implement optimal bandwidth selection methods, package nprobust (see Calonico, Cattaneo, Farrell (2019)). particular, bw_method = \"mse-dpi\" =\"mse-rot\" implement optimal (constant) bandwidth minimizes (integrated) mean squared error k1(v)‚àík0(v)k_1(v) - k_0(v) function, using either direct plug-(dpi) rule--thumb (rot) formula. details, see Calonico, Cattaneo, Farrell (2019) Fan Gijbels (1996), Wand Jones (1994). Later updates package allow variable bandwidth (already implemented nprobust). Notice second residual regression Robinson, want estimate derivative local polynomial function, find optimal bandwidth derivative, hence use plug-rule--thumb methods, well suited (see Fan Gijbels (1996)). estimation optimal bandwidth large sample can take long time (exponential increase sample size). , default specify bw_subsamp_size = 10000 optimal bandwidth computed ‚Äúsmall‚Äù subsample size 10,000. Requires set.seed() running semiivreg replicability. Set NULL (large values) compute bandwidth full sample. Alternatively, one can pre-specify bandwidth directly, shown . parameters bwd bandwidth first residual regression YdY_d WdW_d (XX) PÃÇ\\widehat{P}, estimates respectively E[Yd|P]E[Y_d|P], E[Wd|P]E[W_d|P] E[X|P]E[X|P], order get effects semi-IVs potential outcomes. WdW_d XX, order variable depends order specified original formula. sure match variables correct order (careful factor example). One way check first run without specifying bandwidth checking order variables semiiv$estimate$est0 semiiv$estimate$est1. one specifies one value bw0 bw1, applied covariates. bw_y0, bw_y1 bandwidth second residual regression, k0(v)k_0(v) (MTR0) andk1(v)k_1(v) (MTR1) respectively. important since govern smoothness MTR, thus MTE function. bw_y0 also serves bw local-IV estimation MTE directly. Let us check bandwidth previous computation (default 1/5th support rule). Re-estimate model optimal bandwidth selection (mse-dpi rule) (print_progress=TRUE reporting option see progress function).  Now, illustrate can directly specify bandwidth (adjusts smoothness estimation). Remark: bw_method matter specify bandwidth.  Polynomial degree. One can also specify degree local polynomial estimation pol_degree_locpoly1 pol_degree_locpoly2. Following Fan Gijbels (1996) setting degree equal order derivative function want estimate +1+1, default set pol_degree_locpoly1 = 1 want estimate function directly, pol_degree_locpoly2 = 2 MTE/MTR stage want estimate derivatives control function Œ∫d(u)\\kappa_d(u). Propensity Score estimation. One can also extract propensity score estimation. large number observation, fit almost perfect bias due fact PP estimated small.","code":"semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0)) #> Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot(). mte_plot = semiiv$plot$mte;  mtr_plot = semiiv$plot$mtr; mtr_plot summary(semiiv$estimate$est0) #>  #> Call: #> lm(formula = formuladx, data = residd, weights = weightsd) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -3.7603 -0.6498 -0.0060  0.6563  3.6457  #>  #> Coefficients: #>    Estimate Std. Error t value Pr(>|t|)     #> w0 0.996692   0.008595     116   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9762 on 26778 degrees of freedom #> Multiple R-squared:  0.3343, Adjusted R-squared:  0.3343  #> F-statistic: 1.345e+04 on 1 and 26778 DF,  p-value: < 2.2e-16 summary(semiiv$estimate$est1); #>  #> Call: #> lm(formula = formuladx, data = residd, weights = weightsd) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -4.5990 -0.7789 -0.0022  0.7614  4.3267  #>  #> Coefficients: #>    Estimate Std. Error t value Pr(>|t|)     #> w1 1.287222   0.009057   142.1   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.14 on 23220 degrees of freedom #> Multiple R-squared:  0.4652, Adjusted R-squared:  0.4652  #> F-statistic: 2.02e+04 on 1 and 23220 DF,  p-value: < 2.2e-16 # To be compared with: param_y0[2]; param_y1[2] #> [1] 1 #> [1] 1.3 semiiv$bw #> $bw0 #> [1] 0.199 0.199 #>  #> $bw1 #> [1] 0.199 0.199 #>  #> $bw_y0 #> [1] 0.199 #>  #> $bw_y1 #> [1] 0.199 #>  #> $bw_mte #> [1] 0.199 #>  #> $bw_method #> [1] 0.2 set.seed(1234) semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                    bw_method = \"mse-dpi\", bw_subsamp_size=10000,                     print_progress=TRUE) #> Estimating first stage... First stage estimated.        #> 2nd stage: Estimating MTR and MTE...  #> D= 0, Robinson 1st residual regression of X on P...                #> Progress: 1/2                              Progress: 2/2                              D= 1, Robinson 1st residual regression of X on P...                #> Progress: 1/2                              Progress: 2/2                              Robinson 2nd stage: Bandwidth Selection...                           Robinson 2nd stage: Estimation of k0(v) and k1(v)...  #> Estimation complete. #> Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot(). semiiv$bw #> $bw0 #> [1] 0.08202580 0.04809258 #>  #> $bw1 #> [1] 0.1326332 0.1089366 #>  #> $bw_y0 #> [1] 0.1261527 #>  #> $bw_y1 #> [1] 0.1261527 #>  #> $bw_mte #> [1] 0.1261527 #>  #> $bw_method #> [1] \"mse-dpi\" semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                    bw0=0.05, bw1=0.05, bw_y0 = 0.2, bw_y1 = 0.2) #> Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot(). firststage = semiiv$estimate$propensity # Cannot be compared with param_p directly if V gets rescaled -> but can compare the predicted P with the truth Phat = predict(firststage, newdata=data, type=\"response\")  summary(Phat - data$P) # almost perfect;  #>        Min.     1st Qu.      Median        Mean     3rd Qu.        Max.  #> -0.00145960 -0.00086220  0.00010782  0.00002379  0.00092685  0.00132015"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"semi-iv-sieve-regression","dir":"Articles","previous_headings":"","what":"semi-IV sieve regression","title":"Estimator Performance: general heterogenous treatment effect model","text":"Another approach simply specify flexibly Œ∫d(u)\\kappa_d(u), polynomials example, spirit sieve estimation. potentially less flexible (even though still ), advantage faster giving analytical confidence intervals (biased take account fact PP estimated). use estimation method, specify est_method=\"sieve\".  pol_degree_sieve controls flexibility control function used, controlling degree polynomial used. default set 55. Let us compare two estimation methods results.","code":"semiiv2 = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                      est_method=\"sieve\", pol_degree_sieve=5,                      plotting=FALSE)  mte_plot2 = semiiv2$plot$mte; mtr_plot2 = semiiv2$plot$mtr grid.arrange(mte_plot2, mtr_plot2, ncol=2) # If want to plot on the same plot, need some manipulation of the data  dat = semiiv$data$RES # take the original data dat$V = dat$Phat  # for MTE: mte_plot2 = mte_plot2 + geom_line(aes(x=V, y=mte), linetype=\"dashed\", col=\"#db93a4\", na.rm=TRUE, data=dat)   # for MTR need some manipulation dat_plot = dat; dat1 = dat_plot; dat1$mtr = dat_plot$mtr1; dat1$Treatment = 1 dat0 = dat_plot; dat0$mtr = dat_plot$mtr0; dat0$Treatment = 0; dat2 = rbind(dat1, dat0) dat2$Treatment = as.factor(dat2$Treatment)  mtr_plot2 = mtr_plot2 + geom_line(aes(x=V, y=mtr, col=Treatment, group=Treatment), linetype=\"dashed\", na.rm=TRUE, data=dat2)  grid.arrange(mte_plot2, mtr_plot2, ncol=2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"comparison-with-the-truth","dir":"Articles","previous_headings":"","what":"Comparison with the truth","title":"Estimator Performance: general heterogenous treatment effect model","text":"Let us compute ‚Äòtrue‚Äô underlying MTE. Given model specification, (U0U1)‚àºN((00),(œÉU02œÉU0U1œÉU0U1œÉU12)) \\begin{pmatrix} U_0 \\\\ U_1  \\end{pmatrix} \\sim N \\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma_{U_0}^2 & \\sigma_{U_0U_1} \\\\ \\sigma_{U_0U_1} & \\sigma_{U_1}^2 \\end{pmatrix} \\right)  V=‚àí(U1‚àíU0‚àíC) C‚àºN(0,œÉC2)‚ä•(U0,U1). V = - (U_1 - U_0 - C) \\text{ } C \\sim N(0, \\sigma_C^2) \\perp (U_0, U_1).  Simple computation gives V‚àºN(0,œÉU02+œÉU12‚àí2œÉU0U1+œÉC2)V \\sim N(0, \\sigma_{U_0}^2 + \\sigma_{U_1}^2 - 2 \\sigma_{U_0U_1} + \\sigma_C^2). Let us introduce UD=FV(V)U_D = F_V(V) uniform normalized VV shock. Now, kd(u)=ùîº[Ud|UD=u]k_d(u) = \\mathbb{E}[U_d | U_D=u]. , kd(u)=ùîº[Ud|V=FV‚àí1(u)]k_d(u) = \\mathbb{E}[U_d | V=F_V^{-1}(u)]. Given specification , VV UdU_d bivariate normal : k0(u)=œÉU02‚àíœÉU0U1œÉV2(FV‚àí1(u)‚àíŒºV),k1(u)=‚àíœÉU12+œÉU0U1œÉV2(FV‚àí1(u)‚àíŒºV) \\begin{aligned} k_0(u) &= \\frac{\\sigma_{U_0}^2 - \\sigma_{U_0U_1}}{\\sigma_V^2} \\big(F_{V}^{-1}(u) - \\mu_V \\big), \\\\ k_1(u) &= \\frac{-\\sigma_{U_1}^2 + \\sigma_{U_0U_1}}{\\sigma_V^2} \\big(F_{V}^{-1}(u) - \\mu_V \\big) \\end{aligned}  , true MTR MTE given MTR0(w0,u)=Œ¥0+w0Œ≤0+k0(u),MTR1(w1,u)=Œ¥1+w1Œ≤1+k1(u),MTE(w0,w1,u)=MTR1(w0,u)‚àíMTR0(w1,u)  \\begin{aligned} MTR_0(w_0, u) &= \\delta_0 + w_0 \\beta_0 +  k_0(u), \\\\ MTR_1(w_1, u) &= \\delta_1 + w_1 \\beta_1 +  k_1(u), \\\\ MTE(w_0, w_1, u) &= MTR_1(w_0, u) - MTR_0(w_1, u) \\end{aligned} Evaluate MTR MTE (w0,w1)=(0,0)(w_0, w_1) = (0, 0).  Overall, see common support, MTE precisely estimated . remarkable exploit parametric knowledge underlying distribution shocks . Compared homogenous treatment effect models, estimation heterogenous treatment effects requires observations. Otherwise, MTE well estimated tails common support. solution just trim estimation set parameters well identified .","code":"# True MTE and MTR estimations  seq_p = seq(0, 1, by=0.001);  w0 = 0; w1 = 0;  sigma_V2 = param_error[1] + param_error[2] - 2*param_error[3] + param_error[4] # = var(V); var(data$V) covU0V = param_error[1] - param_error[3] # = cov(data$U0, data$V) covU1V = -param_error[2] + param_error[3] # = cov(data$U1, data$V) ku0 = covU0V/sigma_V2*(qnorm(seq_p) - 0) # 0 = mean(V) ku1 = covU1V/sigma_V2*(qnorm(seq_p) - 0) # 0 = mean(V) true_mtr0 = param_y0[1] + param_y0[2]*w0 + ku0 true_mtr1 = param_y1[1] + param_y1[2]*w1 + ku1 true_mte = true_mtr1 - true_mtr0  newdata = data.frame(Ud=seq_p, w0=0, w1=0) newdata$true_mte = true_mte; newdata$true_mtr1 = true_mtr1; newdata$true_mtr0 = true_mtr0  ## # Remark: alternative estimation method if the truth does not have a simple closed form formula: ## data$diff = data$y1 - data$y0; pol_degree=5 ## true_model_mte = lm(diff~w1 + w0 + poly(Ud, pol_degree, raw=TRUE), data); # MTE ## true_model_mtr1 = lm(y1 ~w1+poly(Ud, pol_degree, raw=TRUE), data) # MTR1 ## true_model_mtr0 = lm(y0 ~w0+poly(Ud, pol_degree, raw=TRUE), data) # MTR0 ## newdata$true_mte = predict(true_model_mte, newdata);  ## newdata$true_mtr1 = predict(true_model_mtr1, newdata); newdata$true_mtr0 = predict(true_model_mtr0, newdata)   # Comparison: mte_plot2 = mte_plot2 + geom_line(data=newdata, aes(x=Ud, y=true_mte), linetype=\"dashed\", col=\"red\") mtr_plot2 = mtr_plot2 + geom_line(data=newdata, aes(x=Ud, y=true_mtr1), linetype=\"dashed\", col=\"blue\") +   geom_line(data=newdata, aes(x=Ud, y=true_mtr0), linetype=\"dashed\", col=\"orange\")  grid.arrange(mte_plot2, mtr_plot2, ncol=2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"other-options","dir":"Articles","previous_headings":"","what":"Other options","title":"Estimator Performance: general heterogenous treatment effect model","text":"Trimming Support. seems relatively well estimated, except tails common support entirely satisfied, MTE identified common support. one wants restrict estimation given common support, easy semiivreg().  Post-estimation prediction. Imagine estimating one wants estimate model several individuals. One way directly specify several ref_indiv running initial regression. ‚Äôs already estimated, one can simply use semiiv_predict function. also allows predict subset specific values VV.","code":"semiiv1 = semiivreg(y~d|w0|w1, data,                      ref_indiv = data.frame(w0=0, w1=0),                      common_supp_trim = c(0.10, 0.90),                     plotting=FALSE) #> Caution: the standard errors around the plot are not correct (underestimated) because of the multiple stages. For proper standard errors, run the bootstrap in semiivreg_boot(). mte_plot = semiiv1$plot$mte; mtr_plot = semiiv1$plot$mtr; grid.arrange(mtr_plot, mte_plot, ncol=2) newdata = data.frame(w0=seq(-1, 1, by=0.5), w1=0) # Predict the outcome  pred = semiiv_predict(semiiv1, newdata=newdata) head(pred$est) # the predicted values; -> can then be used to redo plots for example.  #>     w0 w1 id  Phat     mtr0     mtr1      mte     mte2 mtr0_lwr mtr0_upr #> 1   -1  0  1 0.100       NA       NA       NA       NA       NA       NA #> 1.1 -1  0  1 0.101 1.912715       NA       NA 2.213390 1.494762 2.330669 #> 1.2 -1  0  1 0.102 1.913002 4.137639 2.224637 2.211793 1.498057 2.327946 #> 1.3 -1  0  1 0.103 1.913288 4.136595 2.223306 2.210195 1.501353 2.325224 #> 1.4 -1  0  1 0.104 1.913575 4.135551 2.221976 2.208598 1.504648 2.322502 #> 1.5 -1  0  1 0.105 1.913901 4.134507 2.220606 2.206981 1.507910 2.319893 #>     mtr1_lwr mtr1_upr mte2_lwr mte2_upr       k0       k1   deltak   delta0X #> 1         NA       NA       NA       NA       NA       NA       NA -1.001563 #> 1.1       NA       NA 1.789696 2.637084 2.914278       NA 1.211827 -1.001563 #> 1.2 3.963550 4.311727 1.791001 2.632585 2.914565 4.137639 1.210230 -1.001563 #> 1.3 3.963395 4.309794 1.792306 2.628085 2.914852 4.136595 1.208632 -1.001563 #> 1.4 3.963240 4.307861 1.793610 2.623586 2.915138 4.135551 1.207035 -1.001563 #> 1.5 3.963085 4.305928 1.794824 2.619139 2.915465 4.134507 1.205418 -1.001563 #>     delta1X     se_k0      se_k1 se_deltak  se_delta0X se_delta1X #> 1         0        NA         NA        NA 0.009050053          0 #> 1.1       0 0.2132349         NA 0.2161686 0.009050053          0 #> 1.2       0 0.2116998 0.08881748 0.2146880 0.009050053          0 #> 1.3       0 0.2101647 0.08836390 0.2132074 0.009050053          0 #> 1.4       0 0.2086296 0.08791032 0.2117268 0.009050053          0 #> 1.5       0 0.2071320 0.08745674 0.2102828 0.009050053          0 pred$deltaX # provides the shift in effect of X and Wd -> may be the only thing we care about, know that shifts the curve #>     w0 w1 id    delta0X delta1X  se_delta0X se_delta1X #> 1 -1.0  0  1 -1.0015633       0 0.009050053          0 #> 2 -0.5  0  2 -0.5007816       0 0.004525027          0 #> 3  0.0  0  3  0.0000000       0 0.000000000          0 #> 4  0.5  0  4  0.5007816       0 0.004525027          0 #> 5  1.0  0  5  1.0015633       0 0.009050053          0"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"simulating-data","dir":"Articles","previous_headings":"","what":"Simulating data","title":"Estimator Performance: homogenous treatment effect model","text":"simulate generalized Roy models using simul_data()function. See documentation function details model. Depending chosen parameters, can simulate model homogenous/heterogenous treatment effects, well valid IVs eventually. ‚Äôs . every simulation include covariates (set effect 0), can easily included.","code":""},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"simulate-data","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Simulate data","title":"Estimator Performance: homogenous treatment effect model","text":"model homogenous Treatment Effects (conditional W0,W1W_0, W_1).","code":"# Specification 1 library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1, 0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1, 1, 0.5) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous) # Remark: mean_V and the constant in the probit are playing the same role; normalize one to zero. param = list(param_error, param_Z, param_p, param_y0, param_y1, param_genX, model_type)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"true-unobserved-homogenous-treatment-effects","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"True unobserved homogenous Treatment Effects","title":"Estimator Performance: homogenous treatment effect model","text":", (W0,W1)=(0,0)(W_0, W_1) = (0, 0), effect always 0.4 (see parameters). see , let us just use true unobserved potential outcomes (observed thanks simulation). true model like recover. Note perfect fit exactly error term potential outcomes, U0=U1=UU_0 = U_1 = U. additional error term uncorrelated rest, estimate coefficients (noise).","code":"data$true_TE = data$y1 - data$y0 summary(lm(true_TE ~ w0 + w1, data)) #>  #> Call: #> lm(formula = true_TE ~ w0 + w1, data = data) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -1.065e-13 -2.090e-16 -2.000e-18  1.980e-16  1.602e-13  #>  #> Coefficients: #>               Estimate Std. Error            t value Pr(>|t|)     #> (Intercept)  4.000e-01  1.956e-17  20453045425901668   <2e-16 *** #> w0          -8.000e-01  2.248e-17 -35595035443326064   <2e-16 *** #> w1           5.000e-01  2.259e-17  22130078856903196   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.956e-15 on 9997 degrees of freedom #> Multiple R-squared:      1,  Adjusted R-squared:      1  #> F-statistic: 6.463e+32 on 2 and 9997 DF,  p-value: < 2.2e-16 true_param = c(param_y0[1], param_y1[1] - param_y0[1], param_y0[2], param_y1[2]); true_param #> [1] 3.2 0.4 0.8 0.5 # constant y0, constant y1 - constant y0, effects of w0 on y0, effects of w1 on y1."},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"naive-ols","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Naive OLS","title":"Estimator Performance: homogenous treatment effect model","text":"Obviously, naive OLS estimator biased, endogeneity: UU correlated DD YY. overestimates effect treatment DD -1. individuals high UU select themself D=1D=1 higher YY. Indeed E(U|D=1)>E(U|D=0)E(U | D=1) > E(U | D=0), UU negatively correlated VV (cf covariance parameter param_error), higher UU, lower VV, lower VV, likely one select D=1D=1.","code":"naive_ols = lm(y ~ d + w0 + w1, data); summary(naive_ols) #>  #> Call: #> lm(formula = y ~ d + w0 + w1, data = data) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -3.0172 -0.6411 -0.0147  0.6318  4.1403  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  3.83027    0.01410  271.58   <2e-16 *** #> d           -0.54983    0.02117  -25.98   <2e-16 *** #> w0           0.20181    0.01185   17.04   <2e-16 *** #> w1           0.45476    0.01189   38.24   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9406 on 9996 degrees of freedom #> Multiple R-squared:  0.3026, Adjusted R-squared:  0.3024  #> F-statistic:  1446 on 3 and 9996 DF,  p-value: < 2.2e-16 mean(data$U1[which(data$d == 1)]); mean(data$U0[which(data$d==0)]) #> [1] -0.3762545 #> [1] 0.3864966"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"wrongly-assuming-that-the-semi-ivs-are-valid-ivs","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Wrongly assuming that the semi-IVs are valid IVs","title":"Estimator Performance: homogenous treatment effect model","text":"assume W0W_0 W1W_1 valid IVs (.e., direct effect respective potential outcomes)? estimated coefficients also completely biased , assumes semi-IVs effect outcomes .","code":"library(ivreg) # remark: ivreg is not required otherwise in semiivreg, only in this vignette.  valid_iv = ivreg(y ~ d | w0 + w1 + w0:w1, data=data); summary(valid_iv) #>  #> Call: #> ivreg(formula = y ~ d | w0 + w1 + w0:w1, data = data) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.909987 -0.756706 -0.003831  0.746416  4.813215  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  3.56922    0.02676 133.387   <2e-16 *** #> d           -0.02044    0.04905  -0.417    0.677     #>  #> Diagnostic tests: #>                   df1  df2 statistic p-value     #> Weak instruments    3 9996     886.4  <2e-16 *** #> Wu-Hausman          1 9997      96.0  <2e-16 *** #> Sargan              2   NA    2604.4  <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.124 on 9998 degrees of freedom #> Multiple R-Squared: 0.003449,    Adjusted R-squared: 0.003349  #> Wald test: 0.1736 on 1 and 9998 DF,  p-value: 0.6769"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"semi-iv-estimation-with-semiivreg","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"semi-IV estimation with semiivreg","title":"Estimator Performance: homogenous treatment effect model","text":"Let us now see semi-IV estimator performs. specify estimation homogenous treatment effects, specify est_method=\"homogenous\". performs sieve-like estimation additional constraint restrict MTE constant imposing constraints control function Œ∫0(p)\\kappa_0(p) Œ∫1(p)\\kappa_1(p). estimated coefficients close truth, relatively small standard errors , even though sample size modest (10000 observations). cautious though: standard errors computed without taking account fact propensity score estimated first stage. can correct estimation semiivreg_boot(). typically, first stage well estimated, bias standard errors small, visible .","code":"semiiv = semiivreg(y~d|w0|w1, data, est_method=\"homogenous\", plotting=FALSE) summary_coeff = semiiv$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate  Std_Error    t_value       p_value #> 1 (Intercept) 3.2453691 0.02408485 134.747305  0.000000e+00 #> 2        I(d) 0.3255329 0.04497677   7.237801  4.895871e-13 #> 3 I(1 - d):w0 0.7834206 0.01431262  54.736343  0.000000e+00 #> 4     I(d):w1 0.5194180 0.01432695  36.254620 1.689759e-270 true_param #> [1] 3.2 0.4 0.8 0.5 semiivboot = semiivreg_boot(y~d|w0|w1, data, Nboot=200, est_method=\"homogenous\", plotting=FALSE) # reduce the number of bootstrap simulation for speed;   #> Bandwidth and MTR/MTE estimation on main sample...  #> Estimating first stage... First stage estimated.        #> 2nd stage: Estimating MTR and MTE...  #> Estimation complete.                                              #>  #> Bandwidth and MTR/MTE estimation on main sample: Done.  #> Bootstrap Progress: 1/200 Bootstrap Progress: 2/200 Bootstrap Progress: 3/200 Bootstrap Progress: 4/200 Bootstrap Progress: 5/200 Bootstrap Progress: 6/200 Bootstrap Progress: 7/200 Bootstrap Progress: 8/200 Bootstrap Progress: 9/200 Bootstrap Progress: 10/200 Bootstrap Progress: 11/200 Bootstrap Progress: 12/200 Bootstrap Progress: 13/200 Bootstrap Progress: 14/200 Bootstrap Progress: 15/200 Bootstrap Progress: 16/200 Bootstrap Progress: 17/200 Bootstrap Progress: 18/200 Bootstrap Progress: 19/200 Bootstrap Progress: 20/200 Bootstrap Progress: 21/200 Bootstrap Progress: 22/200 Bootstrap Progress: 23/200 Bootstrap Progress: 24/200 Bootstrap Progress: 25/200 Bootstrap Progress: 26/200 Bootstrap Progress: 27/200 Bootstrap Progress: 28/200 Bootstrap Progress: 29/200 Bootstrap Progress: 30/200 Bootstrap Progress: 31/200 Bootstrap Progress: 32/200 Bootstrap Progress: 33/200 Bootstrap Progress: 34/200 Bootstrap Progress: 35/200 Bootstrap Progress: 36/200 Bootstrap Progress: 37/200 Bootstrap Progress: 38/200 Bootstrap Progress: 39/200 Bootstrap Progress: 40/200 Bootstrap Progress: 41/200 Bootstrap Progress: 42/200 Bootstrap Progress: 43/200 Bootstrap Progress: 44/200 Bootstrap Progress: 45/200 Bootstrap Progress: 46/200 Bootstrap Progress: 47/200 Bootstrap Progress: 48/200 Bootstrap Progress: 49/200 Bootstrap Progress: 50/200 Bootstrap Progress: 51/200 Bootstrap Progress: 52/200 Bootstrap Progress: 53/200 Bootstrap Progress: 54/200 Bootstrap Progress: 55/200 Bootstrap Progress: 56/200 Bootstrap Progress: 57/200 Bootstrap Progress: 58/200 Bootstrap Progress: 59/200 Bootstrap Progress: 60/200 Bootstrap Progress: 61/200 Bootstrap Progress: 62/200 Bootstrap Progress: 63/200 Bootstrap Progress: 64/200 Bootstrap Progress: 65/200 Bootstrap Progress: 66/200 Bootstrap Progress: 67/200 Bootstrap Progress: 68/200 Bootstrap Progress: 69/200 Bootstrap Progress: 70/200 Bootstrap Progress: 71/200 Bootstrap Progress: 72/200 Bootstrap Progress: 73/200 Bootstrap Progress: 74/200 Bootstrap Progress: 75/200 Bootstrap Progress: 76/200 Bootstrap Progress: 77/200 Bootstrap Progress: 78/200 Bootstrap Progress: 79/200 Bootstrap Progress: 80/200 Bootstrap Progress: 81/200 Bootstrap Progress: 82/200 Bootstrap Progress: 83/200 Bootstrap Progress: 84/200 Bootstrap Progress: 85/200 Bootstrap Progress: 86/200 Bootstrap Progress: 87/200 Bootstrap Progress: 88/200 Bootstrap Progress: 89/200 Bootstrap Progress: 90/200 Bootstrap Progress: 91/200 Bootstrap Progress: 92/200 Bootstrap Progress: 93/200 Bootstrap Progress: 94/200 Bootstrap Progress: 95/200 Bootstrap Progress: 96/200 Bootstrap Progress: 97/200 Bootstrap Progress: 98/200 Bootstrap Progress: 99/200 Bootstrap Progress: 100/200 Bootstrap Progress: 101/200 Bootstrap Progress: 102/200 Bootstrap Progress: 103/200 Bootstrap Progress: 104/200 Bootstrap Progress: 105/200 Bootstrap Progress: 106/200 Bootstrap Progress: 107/200 Bootstrap Progress: 108/200 Bootstrap Progress: 109/200 Bootstrap Progress: 110/200 Bootstrap Progress: 111/200 Bootstrap Progress: 112/200 Bootstrap Progress: 113/200 Bootstrap Progress: 114/200 Bootstrap Progress: 115/200 Bootstrap Progress: 116/200 Bootstrap Progress: 117/200 Bootstrap Progress: 118/200 Bootstrap Progress: 119/200 Bootstrap Progress: 120/200 Bootstrap Progress: 121/200 Bootstrap Progress: 122/200 Bootstrap Progress: 123/200 Bootstrap Progress: 124/200 Bootstrap Progress: 125/200 Bootstrap Progress: 126/200 Bootstrap Progress: 127/200 Bootstrap Progress: 128/200 Bootstrap Progress: 129/200 Bootstrap Progress: 130/200 Bootstrap Progress: 131/200 Bootstrap Progress: 132/200 Bootstrap Progress: 133/200 Bootstrap Progress: 134/200 Bootstrap Progress: 135/200 Bootstrap Progress: 136/200 Bootstrap Progress: 137/200 Bootstrap Progress: 138/200 Bootstrap Progress: 139/200 Bootstrap Progress: 140/200 Bootstrap Progress: 141/200 Bootstrap Progress: 142/200 Bootstrap Progress: 143/200 Bootstrap Progress: 144/200 Bootstrap Progress: 145/200 Bootstrap Progress: 146/200 Bootstrap Progress: 147/200 Bootstrap Progress: 148/200 Bootstrap Progress: 149/200 Bootstrap Progress: 150/200 Bootstrap Progress: 151/200 Bootstrap Progress: 152/200 Bootstrap Progress: 153/200 Bootstrap Progress: 154/200 Bootstrap Progress: 155/200 Bootstrap Progress: 156/200 Bootstrap Progress: 157/200 Bootstrap Progress: 158/200 Bootstrap Progress: 159/200 Bootstrap Progress: 160/200 Bootstrap Progress: 161/200 Bootstrap Progress: 162/200 Bootstrap Progress: 163/200 Bootstrap Progress: 164/200 Bootstrap Progress: 165/200 Bootstrap Progress: 166/200 Bootstrap Progress: 167/200 Bootstrap Progress: 168/200 Bootstrap Progress: 169/200 Bootstrap Progress: 170/200 Bootstrap Progress: 171/200 Bootstrap Progress: 172/200 Bootstrap Progress: 173/200 Bootstrap Progress: 174/200 Bootstrap Progress: 175/200 Bootstrap Progress: 176/200 Bootstrap Progress: 177/200 Bootstrap Progress: 178/200 Bootstrap Progress: 179/200 Bootstrap Progress: 180/200 Bootstrap Progress: 181/200 Bootstrap Progress: 182/200 Bootstrap Progress: 183/200 Bootstrap Progress: 184/200 Bootstrap Progress: 185/200 Bootstrap Progress: 186/200 Bootstrap Progress: 187/200 Bootstrap Progress: 188/200 Bootstrap Progress: 189/200 Bootstrap Progress: 190/200 Bootstrap Progress: 191/200 Bootstrap Progress: 192/200 Bootstrap Progress: 193/200 Bootstrap Progress: 194/200 Bootstrap Progress: 195/200 Bootstrap Progress: 196/200 Bootstrap Progress: 197/200 Bootstrap Progress: 198/200 Bootstrap Progress: 199/200 Bootstrap Progress: 200/200  boot_se = semiivboot$estimate$coeff$std_error[1:4] res = as.data.frame(cbind(summary_coeff[1:4,1:3], boot_se)); colnames(res) = c(\"Variable\", \"Estimate\", \"wrong analytic SE\", \"Bootstrapped SE\") res #>      Variable  Estimate wrong analytic SE Bootstrapped SE #> 1 (Intercept) 3.2453691        0.02408485      0.02632599 #> 2        I(d) 0.3255329        0.04497677      0.04930933 #> 3 I(1 - d):w0 0.7834206        0.01431262      0.01379810 #> 4     I(d):w1 0.5194180        0.01432695      0.01631556"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"alternative-semi-iv-strategy-based-on-iv-quantile-regression","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Alternative semi-IV strategy: based on IV-quantile regression","title":"Estimator Performance: homogenous treatment effect model","text":"described Bruneel-Zupanc (2024), another general nonparametric identification strategy semi-IV, building IV-quantile regression (IVQR) framework Chernozhukov Hansen (2005). model homogenous treatment effect, strategy requires interaction W0√óW1W_0 \\times W_1 relevant selection treatment. intuition interaction now serves IV treatment DD within framework. nice feature strategy can implemented standard IV estimation, e.g., ivreg() R. baseline model, interaction significant first stage, problem weak IVs. case baseline model, estimation blow IV irrelevant. However, specify alternative model interaction indeed relevant, also estimate correctly homogenous treatment effect using strategy. now. model param_p[4] gives effect W0√óW1W_0\\times W_1 DD. different 0 . IVQR strategy work. Indeed, estimates coefficients well. Notice semiivreg() function also works : Thus semiivreg()flexible used case. Notice , general IVQR estimation also higher variance estimate builds interaction IV requires large significant effects treatment avoid weak IV concerns. semiivreg() relies fact semi-IV relevant , relatively easier satisfy. Especially semi-IVs strong impact respective potential outcome, relevant soon selection treatment based gains (.e., Y1‚àíY0Y_1 - Y_0). Remark: since know first stage includes interaction, might well include semiivreg follows (previous results including still ok, despite bias prediction propensity score wrong formula)","code":"semiivqr = ivreg(y~d+I(1-d):w0 + I(d):w1|w0+w1+w0:w1, data=data) summary(semiivqr) #> Warning in printHypothesis(L, rhs, names(b)): one or more coefficients in the hypothesis include #>      arithmetic operators in their names; #>   the printed representation of the hypothesis will be omitted #>  #> Call: #> ivreg(formula = y ~ d + I(1 - d):w0 + I(d):w1 | w0 + w1 + w0:w1,  #>     data = data) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -21.7424  -4.4342  -0.0106   4.5084  23.1987  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    8.663     18.635   0.465    0.642 #> d            -10.561     37.440  -0.282    0.778 #> I(1 - d):w0   -4.091     16.779  -0.244    0.807 #> I(d):w1        5.428     16.869   0.322    0.748 #>  #> Diagnostic tests: #>                                 df1  df2 statistic p-value     #> Weak instruments (d)              3 9996     886.4  <2e-16 *** #> Weak instruments (I(1 - d):w0)    3 9996    3691.7  <2e-16 *** #> Weak instruments (I(d):w1)        3 9996    3560.3  <2e-16 *** #> Wu-Hausman                        3 9993     107.9  <2e-16 *** #> Sargan                            0   NA        NA      NA     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 6.212 on 9996 degrees of freedom #> Multiple R-Squared: -29.42,  Adjusted R-squared: -29.43  #> Wald test: 28.43 on 3 and 9996 DF,  p-value: < 2.2e-16 # Model 2 N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.3, 0.4, 0.3, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous)  data2 = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error) semiivqr2 = ivreg(y~d+I(1-d):w0 + I(d):w1|w0+w1+w0:w1, data=data2); summary(semiivqr2) #> Warning in printHypothesis(L, rhs, names(b)): one or more coefficients in the hypothesis include #>      arithmetic operators in their names; #>   the printed representation of the hypothesis will be omitted #>  #> Call: #> ivreg(formula = y ~ d + I(1 - d):w0 + I(d):w1 | w0 + w1 + w0:w1,  #>     data = data2) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.590688 -0.667083 -0.006262  0.664900  3.860807  #>  #> Coefficients: #>             Estimate Std. Error t value   Pr(>|t|)     #> (Intercept)  3.18552    0.05274  60.405    < 2e-16 *** #> d            0.42566    0.09107   4.674 0.00000299 *** #> I(1 - d):w0  0.80693    0.04120  19.586    < 2e-16 *** #> I(d):w1      0.49942    0.01849  27.004    < 2e-16 *** #>  #> Diagnostic tests: #>                                 df1  df2 statistic p-value     #> Weak instruments (d)              3 9996    411.88  <2e-16 *** #> Weak instruments (I(1 - d):w0)    3 9996   1645.20  <2e-16 *** #> Weak instruments (I(d):w1)        3 9996   7846.17  <2e-16 *** #> Wu-Hausman                        3 9993     42.32  <2e-16 *** #> Sargan                            0   NA        NA      NA     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9964 on 9996 degrees of freedom #> Multiple R-Squared: 0.4283,  Adjusted R-squared: 0.4281  #> Wald test:  1385 on 3 and 9996 DF,  p-value: < 2.2e-16 semiiv2 = semiivreg(y~d|w0|w1, data=data2, est_method=\"homogenous\", plotting=FALSE) summary_coeff2 = semiiv2$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff2[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate  Std_Error   t_value        p_value #> 1 (Intercept) 3.1671559 0.05868908 53.964995 0.000000000000 #> 2        I(d) 0.4551946 0.10268723  4.432826 0.000009399856 #> 3 I(1 - d):w0 0.8244073 0.01517866 54.313584 0.000000000000 #> 4     I(d):w1 0.4952332 0.01192557 41.527014 0.000000000000 true_param #> [1] 3.2 0.4 0.8 0.5 semiiv3 = semiivreg(y~d|w0|w1, propensity_formula = d~w0+w1+w0:w1,                      data=data2, est_method=\"homogenous\", plotting=FALSE) fstage = semiiv3$estimate$propensity; summary(fstage) # returns the first stage estimation #>  #> Call: #> glm(formula = propensity_formula, family = binomial(link = \"probit\"),  #>     data = propensity_data, weights = WEIGHTS) #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -0.01376    0.01483  -0.927    0.354     #> w0          -0.23785    0.01392 -17.089   <2e-16 *** #> w1           0.32054    0.01424  22.517   <2e-16 *** #> w0:w1        0.25106    0.01025  24.482   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 13672  on 9999  degrees of freedom #> Residual deviance: 12385  on 9996  degrees of freedom #> AIC: 12393 #>  #> Number of Fisher Scoring iterations: 4 summary_coeff3 = semiiv3$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff3[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate  Std_Error   t_value      p_value #> 1 (Intercept) 3.1768312 0.03566453 89.075380 0.000000e+00 #> 2        I(d) 0.4403100 0.06103333  7.214254 5.816986e-13 #> 3 I(1 - d):w0 0.8227038 0.01466641 56.094412 0.000000e+00 #> 4     I(d):w1 0.4985490 0.01020502 48.853314 0.000000e+00 true_param #> [1] 3.2 0.4 0.8 0.5"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"specification-2-semi-ivs-are-in-fact-valid-ivs","dir":"Articles","previous_headings":"","what":"Specification 2: semi-IVs are in fact valid IVs","title":"Estimator Performance: homogenous treatment effect model","text":"run specification 2 Bruneel-Zupanc (2024), semi-IVs fact valid IVs, need change parameters model. need remove (set zero) direct effect semi-IVs potential outcomes. , simply run previous code. replicate Monte Carlo simulations paper, run several times.","code":"# Specification 2 param_y0 = c(3.2, 0, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param = list(param_error, param_Z, param_p, param_y0, param_y1, param_genX, model_type)"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"the-generalized-roy-model","dir":"Articles","previous_headings":"","what":"The Generalized Roy Model","title":"Simulating Generalized Roy Models","text":"function simulates generalized Roy model described Bruneel-Zupanc (2024). Potential Outcomes. potential outcomes (e.g., earnings) given : Y0=Œ¥0+Œ≤0W0+XŒ≤0X+U0, Y_0 = \\delta_{0} + \\beta_{0} W_0 + X \\beta_{0X} + U_0, Y1=Œ¥1+Œ≤1W1+XŒ≤1X+U1, Y_1 = \\delta_{1} + \\beta_{1} W_1 + X \\beta_{1X} + U_1, W0,W1W_0, W_1 observed semi-IVs excluded Y1Y_1 Y0Y_0 respectively, X=(X1,X2)X=(X_1, X_2) vector binary (X1X_1, e.g., location) continuous (X2X_2, e.g., education parents) observable covariates, U0,U1U_0, U_1 unobservable errors. Selection Problem. observe outcome Y=(1‚àíD)Y0+DY1. Y = (1-D) Y_0 + D Y_1. DD represents (binary) treatment decision (e.g., education choice), given following selection rule: D*=g(W0,W1,X)‚àíV=(Œ±+Œ±0W0+Œ±1W1+Œ±2W0√óW1+Œ±X1X1+Œ±X2X2)‚àíV, D=ùïÄ(D*>0), \\begin{aligned} D^* &= g(W_0, W_1, X) - V \\\\ &= ( \\alpha + \\alpha_0 W_0 + \\alpha_1 W_1 + \\alpha_2 W_0 \\times W_1 + \\alpha_{X_1} X_1 + \\alpha_{X_2} X_2) - V, \\\\ \\text{ } \\quad D &= \\mathbb{}(D^* > 0), \\end{aligned} VV main unobservable probability shock, higher VV, likely one treated. Note normalize UD=FV(V)U_D=F_{V}(V) get normalized probability shock UD‚àºùí∞(0,1)U_D \\sim \\mathcal{U}(0, 1). UDU_D can interpreted unobserved resistance treatment. closer UDU_D 0, likely individual treated. specification yields probability treatment given : Pr(D=1|W0,W1,X)=Pr(V<g(W0,W1,X)). \\textrm{Pr}(D=1 | W_0, W_1, X) = \\textrm{Pr}(V < g(W_0, W_1, X)). Thus, ceteris paribus, lower gg, higher probability treatment.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"unobservables-specification","dir":"Articles","previous_headings":"The Generalized Roy Model","what":"Unobservables specification","title":"Simulating Generalized Roy Models","text":"specification unobservable depends model type.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"heterogenous-treatment-effects","dir":"Articles","previous_headings":"The Generalized Roy Model > Unobservables specification","what":"Heterogenous treatment effects","title":"Simulating Generalized Roy Models","text":"general heterogeneous treatment effect model, : (U0U1)‚àºùí©((00),(œÉU02œÉU0U1œÉU0U1œÉU12)), \\begin{pmatrix} U_0 \\\\ U_1 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{U0} & \\sigma_{U0U1} \\\\ \\sigma_{U0U1} & \\sigma^2_{U1} \\end{pmatrix} \\right), C‚àºùí©(Œºcost,œÉcost2), C \\sim \\mathcal{N}(\\mu_{\\text{cost}}, \\sigma^2_{\\text{cost}}), V=‚àí(U1‚àíU0‚àíC). V = -(U_1 - U_0 - C). Note specification simulates dataset roydata dataset available package, can loaded using data(roydata).","code":"library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric # Example of general model with heterogenous treatment effects N = 100000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"homogenous-treatment-effect","dir":"Articles","previous_headings":"The Generalized Roy Model > Unobservables specification","what":"Homogenous treatment effect","title":"Simulating Generalized Roy Models","text":"restricted homogeneous treatment effect model: (UV)‚àºùí©((0ŒºV),(œÉU2œÉUVœÉUVœÉV2)), \\begin{pmatrix} U \\\\ V \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ \\mu_{V} \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{U} & \\sigma_{UV} \\\\ \\sigma_{UV} & \\sigma^2_{V} \\end{pmatrix} \\right), U0=U1=U. U_0 = U_1 = U. cases, VV normally distributed, selection equation probit model. Covariates Semi-IVs Specification. covariates generated X1‚àºBernoulli(pX1) X2‚àºùí©(ŒºX2,œÉX22). X_1 \\sim \\text{Bernoulli}(p_{X_1}) \\text{ } X_2 \\sim \\mathcal{N}(\\mu_{X_2}, \\sigma^2_{X_2}). semi-IVs X1X_1-specific given : (W0W1)‚àºùí©((ŒºW0,x1ŒºW1,x1),(œÉW02œÉW0W1œÉW0W1œÉW12)), \\begin{pmatrix} W_0 \\\\ W_1 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} \\mu_{W0,x_1} \\\\ \\mu_{W1,x_1} \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{W0} & \\sigma_{W0W1} \\\\ \\sigma_{W0W1} & \\sigma^2_{W1} \\end{pmatrix} \\right), means ŒºW0,x1\\mu_{W0,x_1} ŒºW1,x1\\mu_{W1,x_1} depend binary covariate X1=x1X_1=x_1. function used simulate dataset roydata2 available package, can loaded using data(roydata2).","code":"# Model with homogenous treatment effects - not the same param_error to specify.  library(semiIVreg) N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.5, 0.5, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"simulating-standard-iv-mte-models","dir":"Articles","previous_headings":"","what":"Simulating Standard IV MTE Models","title":"Simulating Generalized Roy Models","text":"function can used model problems IVs used estimate Marginal Treatment Effects, setting effect semi-IVs respective outcomes zero. coefficients can adjusted mimic Roy models James J. Heckman, Urzua, Vytlacil (2006), James J. Heckman Vytlacil (2007). Small adjustments inside function allow mimicking simulation Andresen (2018) (mtefe Stata), 2 regions (state).","code":"# Example of generalized Roy Model where the semi-IVs are valid IVs N = 50000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)  param_y0[2]; # W0 is a valid IV because no direct effect on Y0 #> [1] 0 param_y1[2] # W1 is a valid IV because no direct effect on Y1 #> [1] 0"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christophe Bruneel-Zupanc. Author, maintainer.            https://cbruneel.com","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bruneel-Zupanc C (2025). semiIVreg: Semi-Instrumental Variable (semi-IV) Regression. R package version 1.0.0, https://cbruneelzupanc.github.io/semiIVreg/, https://www.cbruneel.com/.","code":"@Manual{,   title = {semiIVreg: Semi-Instrumental Variable (semi-IV) Regression},   author = {Christophe Bruneel-Zupanc},   year = {2025},   note = {R package version 1.0.0, https://cbruneelzupanc.github.io/semiIVreg/},   url = {https://www.cbruneel.com/}, }"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"semiivreg-r-package-for-semi-iv-regression","dir":"","previous_headings":"","what":"Semi-Instrumental Variable (semi-IV) Regression","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"package provides implementation semi-IV regressions described Bruneel-Zupanc (2024).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"can find development version semiIVreg GitHub. can download install directly local source computer: Alternatively, can directly download GitHub repository:","code":"# If the package is in a .tar.gz file install.packages(\"/path/to/your/package.tar.gz\", repos = NULL, type = \"source\")  # If the package is in a directory install.packages(\"/path/to/your/package_directory\", repos = NULL, type = \"source\") # install.packages(\"devtools\") devtools::install_github(\"cbruneelzupanc/semiIVreg\")"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"semi-iv-regression","dir":"","previous_headings":"","what":"Semi-IV Regression","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"illustrates semiivreg()command reports semi-IV regression. default, reports common support plot propensity score estimated marginal treatment effects (MTE).  One can also easily extract plot marginal treatment responses (MTR):  details, see detailed documentation function detailed vignettes.","code":"library(semiIVreg) ## KernSmooth 2.23 loaded ## Copyright M. P. Wand 1997-2009 data(roydata) # load the data from a simulated Roy model  # semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata, est_method=\"sieve\") semiiv$plot$mtr"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","title":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","text":"functions provides pre-specified transformations control flexibly selection probabilities regression.  correspond \\(\\kappa_d(p)\\) corresponding \\(k_d(u)\\) Bruneel-Zupanc (2024).  Special functions used homogenous treatment effect specifications code different. July 2024: now, polynomial transformations encoded.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","text":"","code":"Kappa_fun(p, pol_degree = 5)  kdu_transform_fun(u, d, pol_degree = 5)  Kappa_homogenous_fun(p, pol_degree = 5)  ku_transform_homogenous_fun(u, pol_degree = 5)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","text":"p Vector propensity scores transform flexible function. pol_degree Degree polynomial transformation. d potential outcome consider (needed \\(k_d(u)\\) heterogenous treatment effects).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","text":"See Andresen (2018) Bruneel-Zupanc (2024) computation details linking \\(\\kappa_d(p)\\) corresponding corresponding \\(k_d(u)\\).  \\(\\kappa_1(p) = E(U_1 | U_D \\leq p) \\) \\(\\kappa_0(p) = E(U_0 | U_D>p) \\) \\(k_d(u) = E(U_d | U_D=u)\\). case homogenous treatment effects: \\(k_0(u) = k_1(u)\\). provides restriction \\(\\kappa\\), hence special functions.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control functions transformations for selection probabilities ‚Äî Kappa_fun","text":"","code":"v = seq(0.1, 0.9, by=0.1) # Transformations for general Heterogenous TE functions: Kappa_fun(p=v, pol_degree=6) #>         1    2     3      4       5        6 #>  [1,] 0.1 0.01 0.001 0.0001 0.00001 0.000001 #>  [2,] 0.2 0.04 0.008 0.0016 0.00032 0.000064 #>  [3,] 0.3 0.09 0.027 0.0081 0.00243 0.000729 #>  [4,] 0.4 0.16 0.064 0.0256 0.01024 0.004096 #>  [5,] 0.5 0.25 0.125 0.0625 0.03125 0.015625 #>  [6,] 0.6 0.36 0.216 0.1296 0.07776 0.046656 #>  [7,] 0.7 0.49 0.343 0.2401 0.16807 0.117649 #>  [8,] 0.8 0.64 0.512 0.4096 0.32768 0.262144 #>  [9,] 0.9 0.81 0.729 0.6561 0.59049 0.531441 #> attr(,\"degree\") #> [1] 1 2 3 4 5 6 #> attr(,\"class\") #> [1] \"poly\"   \"matrix\" k1u = kdu_transform_fun(v, d=1, pol_degree=6)  # Transformations for Homogenous TE functions: Kappa_homogenous_fun(p=v, pol_degree=6) #>       const   1    2     3      4       5        6 #>  [1,]     1 0.1 0.01 0.001 0.0001 0.00001 0.000001 #>  [2,]     1 0.2 0.04 0.008 0.0016 0.00032 0.000064 #>  [3,]     1 0.3 0.09 0.027 0.0081 0.00243 0.000729 #>  [4,]     1 0.4 0.16 0.064 0.0256 0.01024 0.004096 #>  [5,]     1 0.5 0.25 0.125 0.0625 0.03125 0.015625 #>  [6,]     1 0.6 0.36 0.216 0.1296 0.07776 0.046656 #>  [7,]     1 0.7 0.49 0.343 0.2401 0.16807 0.117649 #>  [8,]     1 0.8 0.64 0.512 0.4096 0.32768 0.262144 #>  [9,]     1 0.9 0.81 0.729 0.6561 0.59049 0.531441 ku = ku_transform_homogenous_fun(v, pol_degree=6) # no d anymore, same for both d here;"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data construction functions ‚Äî construct_data","title":"Data construction functions ‚Äî construct_data","text":"functions used construct data given formula. Handles change factor several dummies example. also create reference individuals evaluate MTE MTR (default provided). numerical variables, take average variable; factors, take first level.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data construction functions ‚Äî construct_data","text":"","code":"construct_data(formula, data)  transform_factor(formula, data)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data construction functions ‚Äî construct_data","text":"formula formula model data original dataset","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"MTE and MTR sub-estimation functions ‚Äî mtr_est_poly","title":"MTE and MTR sub-estimation functions ‚Äî mtr_est_poly","text":"functions allow estimate mte mtr, confidence intervals, based coefficients estimated main model main function. details can found Bruneel-Zupanc (2024).  Different formulas must applied depending whether treatment homogenous heterogenous. Bandwidth selection local polynomial regression. Different methods available: \"mse-dpi\", \"mse-rot\" (nprobust) \"arbitrary\" (fixed bandwidth fraction support). Can provide bandwidth main function derivative order. bandwidth can computed subsample data size bw_subsamp_size speed computation. lpoly function estimates (weighted) local polynomial regression specified degree given evaluation points. supports derivative estimation allows heteroscedasticity-consistent standard errors. External weights (weights) allowed.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MTE and MTR sub-estimation functions ‚Äî mtr_est_poly","text":"","code":"mtr_est_poly(data, seq_u,                     bw0 = NULL, bw1=NULL, bw_y0 = NULL, bw_y1=NULL, bw_method = 1/5, kernel,                     bw_subsamp_size = NULL, fast_locpoly = FALSE,                     fast_robinson1 = TRUE, fast_robinson2 = FALSE,                     pol_degree1, pol_degree2, var_outcome, var_treatment, var_w0, var_w1, var_covariates, print_progress)  mtr_fun_poly(ref_indiv, eval_v, est0, est1, kv, se_type, conf_level)  lbw_select(x, y, kernel, degree, drv, bw_method = \"arbitrary\", bw_subsamp_size)  wlocpol(x, y, bandwidth, degree = 2, drv = 1, kernel = \"gaussian\", weights=NULL, x_eval=NULL, gridsize=201, fast_locpoly=FALSE)  mtr_coeff(coeff, vcov, var_cov_2nd, est_method=\"sieve\")  mtr_est(coeff, vcov, names_var, df)  mtr_predict_sieve(coeff, vcov, ref_indiv, var_treatment, var_cov_2nd, pol_degree, seq_u, t_value, est_method, se_type)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MTE and MTR sub-estimation functions ‚Äî mtr_est_poly","text":"seq_u Sequence v compute prediction kd(v). bw_method Method compute bandwidth (bandwdith NULL) bw_subsamp_size Size subsample compute bandwidth. Default NULL (subsample). larger sample size, ignored. se_type \"HC1\", \"nonrobust\" (baseline homoscedastic), ... ref_indiv Newdata (reference individuals) compute predictions. x Vector x values y Vector y values degree Degree polynomial: recommended set drv + 1 drv Derivative order function estimated. supp Support X complete data (necessarily realized X current subsample), order compute bandwidth rule take fraction support. Ensure bandwidth samples D=0 D=1. default supp=NULL, case recompute support x directly. bandwidth Pre-specified bandwidth weights Vector external weights (addition kernel weights) x_eval Vector evaluation points. pre-specified, use grid (gridsize). Default = NULL. gridsize Size grid evenly spaced points x. Default 201. relevant x_eval = NULL. fast_locpoly Default FALSE. fast_locpoly TRUE, use locpoly function Kernsmooth library speed computation. possible external weights used. kernel set Gaussian, locpoly function change Gaussian fast_poly TRUE. coeff Vector (stacked) coefficients mtr0, mtr1. vcov Covariance matrix coefficients. est_method Either \"sieve\" \"homogenous\". names_var Names variables corresponding coefficients. df Degrees freedom p-values. var_cov_2nd Names covariates semi-IVs `fast_robinson1` Default TRUE speed things first stage (many covariates particular). TRUE, use locpoly function Kernsmooth library speed computation Robinson double residual first stage. possible external weights used. Fast Locpoly enforce gaussian kernel. `fast_robinson2` Default FALSE. TRUE, use locpoly function Kernsmooth library speed computation Robinson double residual second stage. possible external weights used. Fast Locpoly enforce gaussian kernel. Default FALSE second stage fast_locpoly returns standard errors gain time important second stage. bw Pre-specified bandwidth","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MTE and MTR sub-estimation functions ‚Äî mtr_est_poly","text":"Returns raw (stacked regression) coefficients covariance matrix corresponding mtr0, mtr1 mte function. Returns mtr0, mtr1 mte estimates tables standard errors p-values. Also exports corresponding estimates vcov matrices. Returns mtr0, mtr1, mte estimates confidence intervals specified ref_indiv.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal Treatment Effect (MTE) and Responses (MTR) plots ‚Äî mtr_plot_fun","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots ‚Äî mtr_plot_fun","text":"Plot MTR MTE estimated curves confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots ‚Äî mtr_plot_fun","text":"","code":"mtr_plot_fun(dat_plot, common_supp)  mte_plot_fun(dat_plot, common_supp)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots ‚Äî mtr_plot_fun","text":"dat_plot Data frame estimated MTE MTR values confidence intervals. Must contain specific variables: Phat, mtr0, mtr1, mtr0_lwr, mtr1_lwr, mtr0_upr, mtr1_upr, mte, mte_lwr, mte_upr. common_supp Vector two values indicating common support plot. Default full support 0,1. conf_band Indicates whether plot confidence intervals. Default \"TRUE\". colMTE, colD0, colD1 Color MTE, MTR0 MTR1 curves.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots ‚Äî mtr_plot_fun","text":"Attention: default semiivreg confidence intervals computed analytically, include error first stage propensity score. corrected semiivreg_boot bootstrapping entire estimation obtain confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Roy Data with Heterogenous Treatment Effects ‚Äî roydata","title":"Generalized Roy Data with Heterogenous Treatment Effects ‚Äî roydata","text":"data frame 100,000 observations drawn simulated Roy model heterogenous treatment effects using simul_data().","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Roy Data with Heterogenous Treatment Effects ‚Äî roydata","text":"","code":"data(roydata)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Generalized Roy Data with Heterogenous Treatment Effects ‚Äî roydata","text":"data contains following information observed standard dataset: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. also reports typically unobserved potential outcomes shocks: y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation. data generated using following R code:","code":"N=100000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.7, 0.7, 0, 0, 0) param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  roydata = simul_data(N, model_type, param_y0, param_y1,                      param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Roy Data with Homogenous Treatment Effects ‚Äî roydata2","title":"Generalized Roy Data with Homogenous Treatment Effects ‚Äî roydata2","text":"data frame 100,000 observations drawn simulated Roy model homogenous treatment effects using simul_data().","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Roy Data with Homogenous Treatment Effects ‚Äî roydata2","text":"","code":"data(roydata2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Generalized Roy Data with Homogenous Treatment Effects ‚Äî roydata2","text":"data contains following information observed standard dataset: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. also reports typically unobserved potential outcomes shocks: y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation. data generated using following R code:","code":"N = 100000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.5, 0.5, 0, 0, 0) param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  roydata2 = simul_data(N, model_type, param_y0, param_y1,                       param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-IV Regression Function ‚Äî semiivreg","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"Semi-IV regression function Bruneel-Zupanc (2024). Syntax inspired ivreg. Returns MTE MTR curves confidence intervals. estimation almost instantaneous (seconds ). default, return analytic standard errors accounting fact propensity score estimated first stage semiivreg. Use semiivreg_boot obtain 'correct' bootstrapped confidence intervals (takes bit longer).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"","code":"semiivreg(formula, data, propensity_formula=NULL, propensity_data = NULL,                  ref_indiv =NULL, firststage_model = \"probit\",                  est_method = \"locpoly\", # \"locpoly\", \"sieve\", or \"homogenous\".                  se_type = \"HC1\",                  bw0 = NULL, bw1 = NULL, bw_y0 = NULL, bw_y1 = NULL, bw_method = 1/5,                  kernel=\"gaussian\",                  pol_degree_locpoly1 = 1, pol_degree_locpoly2 = 2,                  pol_degree_sieve = 5, conf_level = 0.05,                  common_supp_trim=c(0,1), trimming_value=NULL, automatic_trim=FALSE,                  plotting=TRUE, print_progress=FALSE, print_se_message=FALSE)  semiivreg_boot(formula, Nboot=500, data, propensity_formula=NULL, ref_indiv =NULL,                firststage_model=\"probit\", est_method = \"locpoly\", se_type=\"HC1\",                bw0 = NULL, bw1 = NULL, bw_y0 = NULL, bw_y1 = NULL, bw_method = \"rule-of-thumb\",                pol_degree_locpoly1 = 1, pol_degree_locpoly2 = 2,                common_supp_trim=c(0,1), trimming_value = NULL,                automatic_trim = FALSE, plotting=TRUE, conf_level = 0.05, CI_method = \"curve\", weight_var)  semiiv_predict(semiiv, newdata, seq_v=NULL)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"formula Formula regression, form outcome ~ treatment | semi-iv0 | semi-iv1 | commoncovariates.  treatment variable binary (0, 1).  covariates effect differs D=1 D=0 included semi-iv0 semi-iv1.  est_method = \"locpoly\": restrict covariates common effects (implemented), commoncovariates just estimated generally different effect Y0 Y1. data Dataframe containing data. propensity_formula Formula 1st stage. nothing specified, just runs probit d ~ semi-iv0 + semi-iv1 + covariates (removing redundant variables). propensity_data Data used compute 1st stage; ignore default set NULL = data. Mainly useful internal bootstrap function first stage formula different default one. ref_indiv Specify reference individual (terms covariates) evaluate function.  default takes average value covariates (trimmed dataset) compute average estimate. Remark: factors, average computed dummy variables get proper average effect. firststage_model default, first stage probit model. Can specify another model (e.g., \"logit\"). est_method Estimation method: default \"locpoly\" Robinson (1988) double residual regression partially linear model. options include \"sieve\" specify flexibly control function polynomial pol_degree_sieve, \"homogenous\" sieve also impose homogenous treatment effect. bw0, bw1 Bandwidth first residual regressions (Y, Wd X) Phat.  Two possibilities: specify one value applied covariates (Y), specify different bandwidth regression covariate. second case, need specified order covariates specified model. careful factors.  Default NULL computed using specified bw_method. Ideally, one factor covariate, apply bandwidth dummies created factor. bw_y0, bw_y1 Bandwidth second regression Y (net effects covariates) Phat. Default NULL computed using specified bw_method. bw_method Method compute bandwidth local polynomial regressions (first-order derivative). Default option 1/5, arbitrarily sets bw0, bw1, bw_y0 bw_y1 1/5th support (rounded 3th digit). Can place fraction < 1.  Recommended alternatives include (global constant) bandwidth computations nprobust package (Calonico, Cattaneo Farrell, 2019) () \"mse-dpi\": direct plug-MSE optimal bandwidth Fan Gijbels (1996). (ii) \"mse-rot\": rule--thumb implementation MSE-optimal bandwidth. two methods take long large sample: use bw_subsamp_size speed computation. kernel Kernel use local polynomial regressions. Default \"gaussian\" can \"epanechnikov\". Takes longer Epanechnikov (use fast locpoly implementation KernSmooth). bw_subsamp_size Size subsample use bandwidth selection. Default 10,000. Use bw_subsamp_size = NULL use full sample (may take time). Otherwise, recommend set number around 20,000 reasonable computation time (exponentially increasing sample size). bw_subsamp_size introduces randomness bandwidth selection procedure: recommended set seed running semiivreg reproducibility. pol_degree_locpoly1 Degree local polynomial regression covariates Phat. Default 1 recommended Fan Gijbels (1996) want estimate regular function. pol_degree_locpoly2 Degree local polynomial regression Y (net effects covariates) Phat. Default 2 recommended Fan Gijbels (1996) want estimate derivative function. fast_robinson2 TRUE, use locpoly KernSmooth bootstrap. Default TRUE speed things (need compute standard errors bootstrap) Set FALSE want use epanechnikov kernel, want use weights. pol_degree_sieve Degree polynomial transformation control function. se_type Type standard errors main estimation bootstrap replication. Can simplify setting \"nonrobust\" goes (slightly) faster. conf_level Confidence level confidence intervals. common_supp_trim Vector two values indicating set propensity scores evaluate function.  Default full support [0,1]. can trimmed manually. trimming_value Can either vector c(0.05, 0.95) indicating quantile propensity score keep observations D=0 D=1.  Can also single value, case symmetric trimming .  Inserting trimming_value generates automatic_trim = TRUE automatically. automatic_trim TRUE, estimation second stage done common_support . weight_var variable weights applied observations. Default NULL, apply equal weights observations.  Implemented completely est_method = \"sieve\" now. locpoly, weights used computing \"optimal bandwidth\". plotting TRUE wants plot end function, FALSE otherwise. print_progress TRUE wants print progress function, FALSE otherwise (default=FALSE). print_se_message TRUE wants print message standard errors end function, FALSE otherwise (default=TRUE). Nboot Number bootstrap samples. block_boot_var Variable base block bootstrap. default, = NULL standard bootstrap. CI_method \"delta\" delta method, \"curve\" bootstrap MTE curves directly. est_method = \"locpoly\", \"curve\" method possible. print_progress_main Print progress main estimation . semiiv Object returns semiivreg estimation. newdata New data predict MTE MTR. seq_v Sequence v predict MTE MTR. default: NULL fits default interval original semiivreg (equally space grid proba, step size 0.001 common support). `fast_robinson1` Default TRUE speed things first stage (many covariates particular). TRUE, use locpoly function Kernsmooth library speed computation Robinson double residual first stage. possible external weights used. Fast Locpoly enforce gaussian kernel. `fast_robinson2` Default FALSE. TRUE, use locpoly function Kernsmooth library speed computation Robinson double residual second stage. possible external weights used. Fast Locpoly enforce gaussian kernel. Default FALSE second stage fast_locpoly returns standard errors gain time important second stage.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"list following elements: $data Returns data output estimation used plot MTE MTR. details: $RES Dataframe estimated MTE MTR values (confidence intervals est_method=\"sieve\" \"homogenous\") sequence unobservable resistance treatment identifiable common support. $data Original data used estimation added propensity score estimated, named Phat, made transformation eventual factor variables dummies. $ref_indiv Reference individual(s) evaluate MTE MTR. $Xdat Set covariates (output used bootstrap). $deltaX Returns estimated effects covariates semi-IVs (without intercept) specified reference individuals. $estimate Returns estimation : $est, $est0 $est1 est_method = \"locpoly\", est0 est1 returns second stage estimates effect covariates semi-IVs respective potential outcomes. Coming double residual regression √† la Robinson (1988), running -intercept OLS residuals Y-E(Yd|P) residuals every semi-IVs, Wd-E(Wd|P), covariates, X-E(X|P). $mtr0, $mtr1 $mte est_method = \"sieve\" \"homogenous\", returns functional form estimated MTR MTE. $kv Returns estimated k_d(v) (=E(Ud|V=v)). Includes constant. sums effect covariates semi-IVs (deltadX), gives mtr_d. $propensity First stage estimate propensity score. $est_kappa est_method = \"sieve\" \"homogenous\", returns estimated model E(Y|D=d, X, Wd, P). , extract Kappad(P) = E(Ud | D=d, P=p) compute kd(v) mtrd(v, x, wd) functions. $avg_MTE Average MTE identified common support. full common support, estimate ATE(x, w0, w1). est_method=\"homogenous\", MTE constant also gives ATE(x, w0, w1). $bw Returns bandwidth used (estimated via bw_method) Robinson double residual regression. bw0 bw1 bandwidths first residual regressions Yd, Wd X Phat. bw_y0 bw_y1 bandwidths second regression Y (net effects covariates) Phat. one matters smoothness MTE MTR estimates. $plot Returns separately following plot objects: supp (support), mtr, mte mte2. mte reports estimation \"local IV\" approach, standard errors Robinson 2nd stage. mte2 reports MTE estimated difference MTR (without standard errors). $supp Returns common support propensity score Phat two treatment group. $call Returns call function covariates semi-IVs used.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"the-estimated-model","dir":"Reference","previous_headings":"","what":"The estimated model","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"semiivreg estimates marginal treatment effect (MTE) marginal treatment response (MTR) binary treatment variable using semi-IVs, W0 W1. standard IVs (see Andresen, 2018), estimate semi-parametric partially linear model, described Bruneel-Zupanc (2024). details model estimation procedure, see vignette vignette(\"semiIVreg\", package = \"semiIVreg\"), also available online . details use semiivreg function, see also vignettes vignette(\"semiIVreg_heterogenousTE\", package = \"semiIVreg\") vignette(\"semiIVreg_homogenousTE\", package = \"semiIVreg\"). details causal inference semi-IVs general, see Bruneel-Zupanc (2024).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"caution-about-the-estimated-standard-errors","dir":"Reference","previous_headings":"","what":"Caution about the Estimated Standard errors","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"default, est_method=\"locpoly\" returns standard errors.  est_method=\"sieve\" est_method=\"homogenous\", returns analytic standard errors: wrong account fact propensity score estimated.  case, recommend use semiivreg_boot obtain 'correct' bootstrapped confidence intervals. Implemented separately bootstrap takes time, baseline semiivreg function almost instantaneous.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"Bruneel-Zupanc, C. (2024). (fully) exclude , necessary! Identification semi-IVs. arXiv preprint arXiv:2303.12667. empirical applications estimation Marginal Treatment Effects standard IVs, see example:  Carneiro, P., Heckman, J. J., & Vytlacil, E. J. (2011). Estimating marginal returns education. American Economic Review, 101(6), 2754-2781. Brinch, C. N., Mogstad, M., & Wiswall, M. (2017). Beyond LATE discrete instrument. Journal Political Economy, 125(4), 985-1039. particular, see Andresen, M. E. (2018). Exploring marginal treatment effects: Flexible estimation using Stata. Stata Journal, 18(1), 118-158. double residual estimation partially Linear models, see Robinson, P. M. (1988). Root-N-consistent semiparametric regression. Econometrica: Journal Econometric Society, 931-954. local polynomial regressions choice degree & Bandwidth computation Fan, J., & Gijbels, . (1996). Local polynomial modelling applications. Calonico, S., Cattaneo, M. D., & Farrell, M. H. (2019). nprobust: Nonparametric Kernel-Based Estimation Robust Bias-Corrected Inference. Journal Statistical Software, 91(8), 1‚Äì33. https://doi.org/10.18637/jss.v091.i08","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"Christophe Bruneel-Zupanc, cbruneel.com","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-IV Regression Function ‚Äî semiivreg","text":"","code":"# Load data: data(roydata)  # Run the semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata)  semiiv = semiivreg(y~d|w0|w1|Xbinary + Xcontinuous, data=roydata) # with covariates  semiiv = semiivreg(y~d|w0+Xbinary|w1+Xbinary|Xcontinuous, data=roydata)  # Xbinary has different effect on Y0 and Y1, Xcontinuous has the same. semiiv = semiivreg(y~d|w0|w1, data=roydata, propensity_formula = d~w0+w1+w0:w1)  # if want to specify another first stage  semiiv$plot$mtr # if want to plot mtr_plot"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"function simulates data Generalized Roy Model semi-IVs, following simulation specified Bruneel-Zupanc (2024).  details exact specification, see vignettes running vignette(\"simul_data\", package = \"semiIVreg\").","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"","code":"simul_data(N, model_type=\"heterogenous\",            param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"N Number observations model_type Type model: \"heterogenous\" \"homogenous\" param_y0 Parameters Y0 = (delta0, beta0, beta0X1, beta0X2)  .e., intercept, effects w0, X_1, X_2 Y0. param_y1 Parameters Y1: (delta1, beta1, beta1X1, beta1X2).  .e., intercept, effects w1, X1, X2 Y1. param_p Parameters selection: (alpha, alpha0, alpha1, alpha2, alphaX1, alphaX2) .e., intercept effects w0, w1, w0w1, Xbinary, Xcontinuous latent utility. param_Z Parameters simulation semi-IVs:  mean W0 X1=0, W1 X1=0, W0 X1=1, W1 X1=1; variance W0, W1, covariance W0 W1. param_genX Parameters covariates: p_X1, mu_X2, sigma_X2. param_error Parameters error terms: depends model_type:  heterogenous: variance U0, U1, covariance U0 U1, variance cost (mean 0).  homogenous: variance U, variance V, covariance U V.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"data frame following columns: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"function simulates data Generalized Roy Model semi-IVs, following simulation specified Bruneel-Zupanc (2024).  details exact specification, see vignette running vignette(\"simul_data\", package = \"semiIVreg\"). One can use simulate general model heterogenous treatment effects, also restricted ones homogenous treatment effects. simul_data used simulate dataset available package, data(roydata) obtain simulated model heterogenous treatment effect, data(roydata2) obtain simulated model homogenous treatment effect.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"Bruneel-Zupanc, C. (2023). (fully) exclude , necessary! Identification semi-IVs. arXiv preprint arXiv:2303.12667. Andresen, M. E. (2018). Exploring marginal treatment effects: Flexible estimation using Stata. Stata Journal, 18(1), 118-158. Heckman, J. J., Urzua, S., & Vytlacil, E. (2006). Understanding instrumental variables models essential heterogeneity. Review Economics Statistics, 88(3), 389-432. Heckman, J. J., & Vytlacil, E. J. (2007). Econometric evaluation social programs, part II: Using marginal treatment effect organize alternative econometric estimators evaluate social programs, forecast effects new environments. Handbook econometrics, 6, 4875-5143.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate data from the Generalized Roy Model with semi-IVs ‚Äî simul_data","text":"","code":"N = 10000; set.seed(12345)  # Example 1: Heterogenous Treatment Effects. model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 Xbinary0, meanW1 Xbinary0, meanW0 Xbinary1, meanW1 Xbinary1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, W0, W1, W0xW1, Xbinary, Xcontinuous param_y0 = c(3.2, 0.8, 0, 0) # intercept, W0, Xbinary, Xcontinuous; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.4 = ATE; W1, Xbinary, Xcontinuous; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)   # Example 2: Homogenous Treatment Effects (constant MTE) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.5, 0.5, 0, 0, 0) # the constant <=> mean_V param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  data1 = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)   # Set the effects of w1 or w0 on its outcome to zero if want a valid IV, e.g., # param_y1 = c(3.2+0.4, 0, 0, 0) # w1 is a valid IV # or: param_y0 = c(3.2, 0, 0, 0) # w0 is a valid IV"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Propensity score support plot ‚Äî supp_plot_fun","title":"Propensity score support plot ‚Äî supp_plot_fun","text":"Returns support plot treatment status propensity score Phat included dataset.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propensity score support plot ‚Äî supp_plot_fun","text":"","code":"supp_plot_fun(data, common_supp)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Propensity score support plot ‚Äî supp_plot_fun","text":"data Dataframe containing treatment status, factor variable Treatment propensity score name Phat. common_supp Vector two values indicating common support plot. Default full support 0,1. colMTE, colD0, colD1 Color MTE, MTR0 MTR1 curves.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Propensity score support plot ‚Äî supp_plot_fun","text":"","code":"# Plot the true common support (with true - unobserved - propensity score) # Using simulated data. data(roydata); data=roydata;  # Syntax adjustment to use the function data$Treatment = factor(data$d) data$Phat = data$P # P is unobserved, we only know it because simulation here  #common_supp can be determined by looking at the plot - it's not necessary, just a graphical option supp_P0 = c(min(data$Phat[which(data$d == 0)]), max(data$Phat[which(data$d== 0)])) supp_P1 = c(min(data$Phat[which(data$d == 1)]), max(data$Phat[which(data$d == 1)])) common_supp = c(max(supp_P0[1], supp_P1[1]), min(supp_P0[2], supp_P1[2]))  supp_plot = supp_plot_fun(data, common_supp); supp_plot"}]
