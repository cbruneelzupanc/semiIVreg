[{"path":"https://cbruneelzupanc.github.io/semiIVreg/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 semiIVreg authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"semiIVreg: R package for semi-IV regression","text":"package provides estimation procedure semi-IVs, Bruneel-Zupanc (2024). particular, main function semiivreg() estimates marginal treatment effect (MTE) marginal treatment response (MTR).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"semiIVreg: R package for semi-IV regression","text":"development version semiIVreg hosted GitHub . can conveniently installed via install_github() function remotes package.","code":"remotes::install_github(\"cbruneelzupanc/semiIVreg\")"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"semiIVreg: R package for semi-IV regression","text":"semiivreg estimates marginal treatment effect (MTE) marginal treatment response (MTR) following model. potential outcomes given semi-parametric model: Y0=δ0+W0β0+Xβ0X+U0,(1) Y_0 = \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + U_0, \\quad \\quad \\quad (1) Y1=δ1+W1β1+Xβ1X+U1,(2) Y_1 = \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + U_1, \\quad \\quad \\quad (2) selection rule D*=g(W0,W1,X)−V=−(α+α0W0+α1W1+αXX)−V,(3) D=𝕀(D*>0), \\begin{aligned} D^* &= g(W_0, W_1, X) - V \\\\ &= - (\\alpha + \\alpha_0 W_0 + \\alpha_1 W_1 + \\alpha_{X} X ) - V, \\quad \\quad \\quad (3) \\\\ \\text{ } \\quad D &= \\mathbb{}(D^* > 0), \\end{aligned} semi-IVs: W0W_0 (respectively W1W_1) semi-IVs excluded Y1Y_1 (resp. Y0Y_0). W0W_0 W1W_1 may contain several variables. Nonparametric identification requires WdW_d contains least one excluded variable (see Bruneel-Zupanc (2024)). Covariates: XX covariates affect potential outcomes. default, different effect covariates across alternatives, (.e., β0X≠β1X\\beta^X_{0} \\neq \\beta^X_{1}). , include covariates separately MTR formulas: semiivreg(y~d|w0+x|w1+x, data). One can restrict effect XX across potential outcomes (.e., β0X=β1X\\beta^X_{0} = \\beta^X_{1}). , specify: semiivreg(y~d|w0|w1|x, data). Unobservables: U0U_0 U1U_1 general unobservables (may include several shocks, may across alternatives) affecting outcomes. Generally normalize E(Ud|X,Wd)=0E(U_d | X, W_d)=0. VV scalar unobservable affects selection. lower VV, likely one select treatment. Nonparametric identification requires independence, .e., (U0,U1,V)⊥(W0,W1)|X(U_0, U_1, V) \\perp (W_0, W_1) | X. estimation , additionally assume additive separability covariates XX, .e., E(Ud|V,X)=E(Ud|V)E(U_d | V, X) = E(U_d | V) d=0,1d=0,1. assumption necessary identification, estimation. standard simplification helps estimation. See Carneiro, Heckman, Vytlacil (2011), Brinch, Mogstad, Wiswall (2017) Andresen (2018) comparable examples estimation MTE IVs. Remark flexibility model: note W0W_0 W1W_1 can flexible transformations (polynomial, splines) specific variables, outcome equations quite flexible (also specify interactions WdW_d XX). semi-parametric model main assumption separability unobservables X,WdX, W_d, otherwise model general can .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"estimation-procedure","dir":"Articles","previous_headings":"","what":"Estimation procedure","title":"semiIVreg: R package for semi-IV regression","text":"estimation procedure closely follows counterpart estimation MTE standard IVs, see e.g., Andresen (2018). command estimates Marginal Treatment Responses (MTR) Marginal Treatment Effects (MTE). Define normalized unobserved resistance treatment UD=FV(V)∼Uniform(0,1)U_D = F_V(V) \\sim Uniform(0, 1). , MTRs given : MTRd(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=δd+Wdβd+XβdX+E(Ud|X=x,Wd=wd,UD=u)=δd+Wdβd+XβdX+E(Ud|UD=u)=δd+Wdβd+XβdX+kd(u), \\begin{aligned} MTR_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + E(U_d|X=x, W_d=w_d, U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + E(U_d|U_D=u) \\\\ &= \\delta_{d} + W_d \\beta_d + X \\beta^X_{d} + k_d(u), \\end{aligned}  last equalities comes fact E(Ud|X=x,Wd=wd,UD=u)=E(Ud|UD=u)E(U_d|X=x, W_d=w_d, U_D=u) = E(U_d|U_D=u) separability independence, just define kd(u)=E(Ud|UD=u)k_d(u) = E(U_d|U_D=u). , Marginal Treatment Effects (MTE) given MTE(u,x,w0,w1)=E(Y1−Y0|X=x,W0=w0,W1=w1,UD=u)=MTR1(u,w1,x)−MTR0(u,w0,x). \\begin{aligned} MTE(u, x, w_0, w_1) &= E(Y_1 - Y_0 | X = x, W_0=w_0, W_1=w_1, U_D=u) \\\\ &= MTR_1(u, w_1, x) - MTR_0(u, w_0, x). \\end{aligned} Remark: MTR MTE estimated given covariates semi-IVs, (X,W0,W1)(X, W_0, W_1). specified using ref_indiv. default, computes ‘average individual’ (take reference level factor). estimation proceeds two stages: first estimate propensity treated, PP, potential outcome treatment parameters.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"st-stage-propensity-score","dir":"Articles","previous_headings":"Estimation procedure","what":"1st stage: propensity score","title":"semiIVreg: R package for semi-IV regression","text":"Estimate propensity score P̂\\widehat{P} treatment selection equation (3). default, function g(⋅)g(\\cdot) given simple linear specification , code allows specifying first stage. example: default, estimation assumes probit model first stage (.e., assumes VV normally distributed). However, can specify models (e.g., logit) using firststage_model argument. theory, specification first stage added, even possible estimate propensity score outside semiivreg command (feature implemented yet).","code":"semiivreg(y~d|w0+x|w1+x, data,             propensity_formula = d~w0+w1+w0:w1+w0:x+w1:x+I(w0^2)+I(w1^2))"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"estimated-objects","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Estimated objects","title":"semiIVreg: R package for semi-IV regression","text":"First, given estimated P̂\\widehat{P}, second stage estimates following semi-parametric partially linear model potential outcomes E[Y|D=0,W0,X,P̂]=δ0+W0β0+Xβ0X+κ0(P̂),E[Y|D=1,W1,X,P̂]=δ1+W1β1+Xβ1X+κ1(P̂), \\begin{aligned} E[Y|D=0, W_0, X, \\widehat{P}] &= \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + \\kappa_0(\\widehat{P}), \\\\ E[Y|D=1, W_1, X, \\widehat{P}] &= \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + \\kappa_1(\\widehat{P}),  \\end{aligned}  κd(P)\\kappa_d(P) control functions, equal κ1(P)=E[U1|D=1,W1,W0,X,P]=E[U1|D=1,P]=E[U1|UD≤P]κ0(P)=E[U0|D=0,W1,W0,X,P]=E[U0|D=0,P]=E[U0|UD>P]. \\begin{aligned} \\kappa_1(P) &= E[ U_1 | D=1, W_1, W_0, X,P] = E[U_1|D=1, P] = E[U_1 | U_D \\leq P] \\\\ \\kappa_0(P) &= E[ U_0 | D=0, W_1, W_0, X,P] = E[U_0|D=0, P] = E[U_0 | U_D > P]. \\end{aligned}  partially linear model control functions nonparametric can estimated less flexibly (see ). parameters δd,βd,βdX\\delta_d, \\beta_d, \\beta^X_d flexible control function κd()\\kappa_d() estimated, don’t need estimate parameters obtain MTE MTR. need also obtain derivative estimated κd\\kappa_d. Indeed, define k̂1(u)=E[U1|UD=u]=κ̂1(u)+uκ̂1′(u),k̂0(u)=E[U0|UD=u]=κ̂0(u)−(1−u)κ̂0′(u). \\begin{aligned} \\widehat{k}_1(u) &= E[ U_1 | U_D=u] = \\widehat{\\kappa}_1(u) + u \\widehat{\\kappa}_1'(u), \\\\ \\widehat{k}_0(u) &= E[ U_0 | U_D=u] = \\widehat{\\kappa}_0(u) - (1-u) \\widehat{\\kappa}_0'(u). \\end{aligned} , Marginal Treatment Responses given : MTR̂d(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=δ̂d+wdβ̂d+xβ̂dX+k̂d(u) \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = \\widehat{\\delta}_{d} + w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{k}_d(u) \\end{aligned} Marginal Treatment Effects : MTÊ(u,x,w0,w1)=MTR̂1(u,w1,x)−MTR̂0(u,w0,x). \\begin{aligned} \\widehat{MTE}(u, x, w_0, w_1) = \\widehat{MTR}_1(u, w_1, x) - \\widehat{MTR}_0(u, w_0, x). \\end{aligned} Consequently, estimation estimating parameters κd\\kappa_d. Several estimation method est_method implemented semiivreg(). describe .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-1--double-residual-regression-robinson-1988","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 1. Double residual regression, Robinson (1988)","title":"semiIVreg: R package for semi-IV regression","text":"default method, implemented est_method=\"locpoly\" run double residual regression, à la Robinson (1988), order estimate partially linear model. implement similarly separate approach Andresen (2018) estimation MTE IVs. estimate using separate approach, .e., estimate separately treated untreated samples, implementing following steps: Step 1. Estimate E(Yd|D=d,P̂)E(Y_d | D=d, \\widehat{P}), E(Wd|D=d,P̂)E(W_d | D=d, \\widehat{P}) E(X|D=d,P̂)E(X | D=d, \\widehat{P}) nonparametric local polynomial regression. specify bandwidth local polynomial regression, use bw0 bw1. specified, bandwidth automatically computed using method bw_method. default fast \"plug-\" method library KernSmooth. can also specify degree polynomial pol_degree_locpoly1. default, equal 11 recommended Fan Gijbels (2003) (order function target +1+1). Step 2. subsample, compute residuals eYd=Yd−E(Yd|D=d,P̂)e_{Y_d} = Y_d - E(Y_d | D=d, \\widehat{P}), eWd=Wd−E(Wd|D=d,P̂)e_{W_d} = W_d - E(W_d | D=d, \\widehat{P}) eXd=X−E(X|D=d,P̂)e_X^d = X - E(X | D=d, \\widehat{P}). , run first residual regression, -intercept OLS:eYd=eWdβd+eXdβdX+Ũd. e_{Y_d} = e_{W_d} \\beta_d + e_X^d \\beta^X_d + \\tilde{U}_d.  regression subsample D=dD=d, provides consistent estimates βd\\beta_d βdX\\beta^X_d. Indeed, residual equation equivalent toYd−E[Yd|D=d,P̂]=(Wd−E[Wd|D=d,P̂])βd+E(X−E[X|D=d,P̂])βdX+(Ud−E[Ud|D=d,P̂]). Y_d - E[Y_d | D=d, \\widehat{P}] = (W_d - E[W_d | D=d, \\widehat{P}]) \\beta_d + E(X - E[X | D=d, \\widehat{P}]) \\beta_d^X + (U_d - E[U_d | D=d, \\widehat{P}]).  denote Ũd=Ud−E[Ud|D=d,P̂]\\tilde{U}_d = U_d - E[U_d | D=d, \\widehat{P}], E[Ũd|D=d,P̂]=0E[\\tilde{U}_d | D=d,  \\widehat{P}] = 0, -intercept residual OLS regression gives consistent estimates. Step 3. Construct Ỹd=Y−Wdβd̂−XβdX̂\\tilde{Y}_d = Y - W_d \\widehat{\\beta_d} - X \\widehat{\\beta^X_d}, sample D=dD=d, .e., outcome net effect covariates. Ỹd=δd+Ud.\\tilde{Y}_d = \\delta_d + U_d.  yields κ̃d(P)=E[Ỹd|D=d,P] \\tilde{\\kappa}_d(P) = E[\\tilde{Y}_d | D=d, P] Step 4. Estimate κ̃d(P)\\tilde{\\kappa}_d(P) using second nonparametric local polynomial regression Ỹd\\tilde{Y}_d PP. specify bandwidth local polynomial regression, use bw_y0 bw_y1. specified, bandwidth automatically computed using method bw_method. default fast \"plug-\" method library KernSmooth. can also specify degree polynomial pol_degree_locpoly2. default, equal 22 recommended Fan Gijbels (2003) want estimate derivative, k̃d(u)=E[δd+Ud|UD=u]\\tilde{k}_d(u) = E[\\delta_d + U_d|U_D=u]. κ̃d\\tilde{\\kappa}_d, can compute k̃̂1(u)=E[δ1+U1|UD=u]=κ̃̂1(u)+uκ̃̂1′(u),k̃̂0(u)=E[δ0+U0|UD=u]=κ̃̂0(u)−(1−u)κ̃̂0′(u). \\begin{aligned} \\widehat{\\tilde{k}}_1(u) &= E[ \\delta_1 + U_1 | U_D=u] = \\widehat{\\tilde{\\kappa}}_1(u) + u \\widehat{\\tilde{\\kappa}}_1'(u), \\\\ \\widehat{\\tilde{k}}_0(u) &= E[ \\delta_0 + U_0 | U_D=u] = \\widehat{\\tilde{\\kappa}}_0(u) - (1-u) \\widehat{\\tilde{\\kappa}}_0'(u). \\end{aligned} Using k̃̂d(u)\\widehat{\\tilde{k}}_d(u) estimated β̂d,β̂dX\\widehat{\\beta}_d, \\widehat{\\beta}^X_d, can compute MTR subsample D=dD=d, MTR̂d(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=wdβ̂d+xβ̂dX+k̃̂d(u). \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{\\tilde{k}}_d(u). \\end{aligned}  Remark definition κ̃d(P)\\tilde{\\kappa}_d(P), equivalent defining general shock include constant, Ũd=δd+Ud\\tilde{U}_d = \\delta_d + U_d. innoccuous yield MTR/MTE end. MTR estimated separately subsample, can estimate MTE: MTR̂d(u,wd,x)=E(Yd|X=x,Wd=wd,UD=u)=wdβ̂d+xβ̂dX+k̃̂d(u)MTÊ(u,x,w0,w1)=MTR̂1(u,w1,x)−MTR̂0(u,w0,x). \\begin{aligned} \\widehat{MTR}_d(u, w_d, x) &= E(Y_d | X=x, W_d=w_d, U_D=u) = w_d \\widehat{\\beta}_d + x \\widehat{\\beta}^X_{d} + \\widehat{\\tilde{k}}_d(u) \\\\ \\widehat{MTE}(u, x, w_0, w_1) &= \\widehat{MTR}_1(u, w_1, x) - \\widehat{MTR}_0(u, w_0, x). \\end{aligned} Advantages. main advantage double residual regression robust misspecification nonparametric κd\\kappa_d function, see Robinson (1988). However, still requires specify bandwidths. order obtain standard errors around estimates, given PP estimated first stage, bootstrap standard errors using semiivreg_boot(). function takes longer default estimation almost instantaneous.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-2--sieve-estimation","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 2. Sieve estimation","title":"semiIVreg: R package for semi-IV regression","text":"alternative method use sieve approach, implemented est_method=\"sieve\", estimate second stage. idea simply specify control function κd\\kappa_d flexible function PP, using flexible functional form. default use polynomial transformation degree pol_degree_sieve=5 κ0(P)\\kappa_0(P) κ1(P)\\kappa_1(P). , estimate second stage using stacked regression form: E[Y|W0,W1,X,P̂]=D×(δ1+W1β1+Xβ1X+κ1(P̂))+(1−D)×(δ0+W0β0+Xβ0X+κ0(P̂)). \\begin{aligned} E[Y|W_0, W_1, X, \\widehat{P}] = &D \\times ( \\delta_{1} + W_1 \\beta_1 + X \\beta^X_{1} + \\kappa_1(\\widehat{P}) ) + \\\\ &(1-D) \\times ( \\delta_{0} + W_0 \\beta_0 + X \\beta^X_{0} + \\kappa_0(\\widehat{P})). \\end{aligned}  stacked regression separately order allow restrict covariates effect potential outcomes (e.g., β0X=β1X\\beta_0^X = \\beta_1^X). obtain κ̂d(P)\\widehat{\\kappa}_d(P), proceed obtain kd(u)k_d(u) MTR/MTE. polynomial functional form, kd(u)k_d(u) known functional form based estimated coefficients κd\\kappa_d, easy compute. Advantages. main advantage sieve approach faster easier implement (\"locpoly\" also fast anyway). also provides analytical standard errors. wrong take account P̂\\widehat{P} estimated first stage, , P̂\\widehat{P} well estimated, analytical standard errors close true one can obtain bootstrap semiivreg_boot(). disadvantage less robust misspecification control function polynomial. Even though, visible vignette, still works well examples, even underlying κd\\kappa_d polynomial.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"method-3--special-case-with-homogenous-treatment-effects","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Method 3. Special Case with Homogenous Treatment Effects","title":"semiIVreg: R package for semi-IV regression","text":"Using est_method=\"homogenous\", semiivreg() can also estimate restricted model assume treatment effects homogenous, .e., MTE(u,x,w0,w1)=MTE(x,w0,w1)MTE(u, x, w_0, w_1) = MTE(x, w_0, w_1), varies observable covariates, constant respect UDU_D. homogenous treatment effect assumption equivalent imposing underlying model corresponds general potential outcome model (1)-(2), additional restriction U0=U1=UU_0 = U_1 = U. estimated using procedure similar sieve approach heterogenous treatment effects, impose additional known restriction control functions κ0(P)\\kappa_0(P) κ1(P)\\kappa_1(P) second stage estimation. Indeed, E(U)=0=E(U|UD≤P)P+E(U|UD>P)(1−P) E(U) = 0 = E(U | U_D \\leq P) P + E(U | U_D > P) (1-P) , κ0(P)=−κ1(P)P1−P\\kappa_0(P) = -\\kappa_1(P) \\frac{P}{1-P}, one can check yields k0(u)=k1(u)=k(u)k_0(u) = k_1(u) = k(u). Thus, MTE constant (k1(u)−k0(u)=0k_1(u) - k_0(u) = 0, cancels ), equal : MTÊ(x,w0,w1)=δ̂1−δ̂0+w1β̂1−w0β̂0+x(β̂1X−β̂0X). \\widehat{MTE}(x, w_0, w_1) = \\widehat{\\delta}_{1} - \\widehat{\\delta}_{0} + w_1 \\widehat{\\beta}_1 - w_0 \\widehat{\\beta}_0 + x (\\widehat{\\beta}^X_{1} - \\widehat{\\beta}^X_{0}). Note MTR still varies uu k(u)k(u) constant, MTE .","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"caution-about-the-estimated-standard-errors","dir":"Articles","previous_headings":"Estimation procedure > 2nd stage: marginal treatment responses","what":"Caution about the Estimated Standard Errors","title":"semiIVreg: R package for semi-IV regression","text":"default, est_method=\"sieve\" \"homogenous” return analytic standard errors… accounting fact propensity score estimated first stage semiivreg. Thus, wrong (bias small first stage well estimated, see simulations example). Use semiivreg_boot obtain ‘correct’ bootstrapped confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg.html","id":"illustration-with-simulated-roy-model","dir":"Articles","previous_headings":"","what":"Illustration with simulated Roy model","title":"semiIVreg: R package for semi-IV regression","text":"illustrates semiivreg()command reports semi-IV regression. default, reports common support plot propensity score estimated marginal treatment effects (MTE). est_method = \"locpoly\" default.  One can also easily extract plot marginal treatment responses (MTR):  one wants use sieve estimation method, simply run:   One advantage sieve reports confidence interval (though wrong take account first stage error) also gives functional form MTR MTE, obtainable running code . Similarly, homogenous treatment effects also provide functional form estimation. details, see vignettes estimation heterogenous homogenous treatment effects. Refer also Bruneel-Zupanc (2024).","code":"library(semiIVreg) data(roydata) # load the data from a simulated Roy model  # semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata) semiiv$plot$mtr # semi-IV sieve regression semiiv = semiivreg(y~d|w0|w1, data=roydata, est_method=\"sieve\") semiiv$plot$mtr semiiv$est$mtr0;  #>      Variable    Estimate    Std_Error      t_value     p_value #> 1 (Intercept)   2.7581424 9.298226e-01   2.96631018 0.003014676 #> 2  kd(v): v^1  -0.6853761 1.229132e+01  -0.05576099 0.955532327 #> 3  kd(v): v^2  12.0175370 5.692871e+01   0.21109801 0.832811220 #> 4  kd(v): v^3 -30.6762292 1.188494e+02  -0.25811010 0.796322466 #> 5  kd(v): v^4  31.3667340 1.142864e+02   0.27445721 0.783733849 #> 6  kd(v): v^5 -10.8461651 4.113650e+01  -0.26366279 0.792040318 #> 7          w0   0.8002338 3.955818e-03 202.29288041 0.000000000 semiiv$est$mtr1;  #>      Variable    Estimate    Std_Error      t_value       p_value #> 1 (Intercept)   4.3655568  0.142511442  30.63302633 3.985092e-205 #> 2  kd(v): v^1  -3.2471062  3.735243561  -0.86931580  3.846765e-01 #> 3  kd(v): v^2   4.2847118 26.418324185   0.16218711  8.711588e-01 #> 4  kd(v): v^3   4.5087919 75.498769743   0.05972007  9.523787e-01 #> 5  kd(v): v^4 -17.9382899 93.543557546  -0.19176403  8.479274e-01 #> 6  kd(v): v^5  11.5530308 41.752329058   0.27670387  7.820081e-01 #> 7          w1   0.4977251  0.003904244 127.48309330  0.000000e+00 semiiv$est$mte #>      Variable    Estimate    Std_Error      t_value    p_value #> 1 (Intercept)   1.6074144 9.406804e-01    1.7087784 0.08749511 #> 2  kd(v): v^1  -2.5617302 1.284634e+01   -0.1994132 0.84193997 #> 3  kd(v): v^2  -7.7328252 6.275990e+01   -0.1232128 0.90193882 #> 4  kd(v): v^3  35.1850210 1.408021e+02    0.2498898 0.80267307 #> 5  kd(v): v^4 -49.3050239 1.476881e+02   -0.3338455 0.73849682 #> 6  kd(v): v^5  22.3991960 5.861287e+01    0.3821549 0.70234729 #> 7    + W1: w1   0.4977251 3.904244e-03  127.4830933 0.00000000 #> 8    - W0: w0  -0.8002338 3.955818e-03 -202.2928804 0.00000000"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"simulate-data","dir":"Articles","previous_headings":"","what":"Simulate data","title":"Estimator Performance: general heterogenous treatment effect model","text":"simulate generalized Roy models using simul_data()function. See documentation function details model. Depending chosen parameters, can simulate model homogenous/heterogenous treatment effects, well valid IVs eventually. ’s . every simulation include covariates (set effect 0), can easily included.","code":"# Model library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric N = 50000; set.seed(1234) # Specification model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"semi-iv-regression","dir":"Articles","previous_headings":"","what":"semi-IV regression","title":"Estimator Performance: general heterogenous treatment effect model","text":"Let us apply directly semiivreg()function. Compute MTE MTR reference individuals average value semi-IVs, .e., (W0,W1)=(0,0)(W_0, W_1) = (0, 0) . Remark: MTE(u,w0,w1,x)MTE(u, w_0, w_1, x) depend XX W0,W1W_0, W_1, always need pick reference individual. default, semiivreg computes average individuals (continuous/binary covariates semi-IVs), takes ‘reference level’ factor variables. terms estimation method, default, semivreg() estimates second-stage local polynomial regression, spirit double residual regression partially linear models Robinson (1988). specified using default est_method=\"locpoly\". estimation advantage robust misspecification control function κd(u)\\kappa_d(u) functional form.  Let us report also marginal treatment responses (MTR):  Direct effect semi-IVs. Also estimates effect semi-IV respective potential outcomes. see : Notice standard errors biased take account propensity score estimated. Standard errors. get proper standard errors MTE/MTR effects semi-IVs default \"locpoly\"estimation method, use bootstrap function semiivreg_boot(). takes longer estimate though. Bandwidth Specification. default, est_method=\"locpoly\", bandwidth provided, bandwidth computed using bw_method. default bw_method simple rule--thumb rule thumb estimator locpol package, implements Fan Gijbels (2003) rule thumb bandwidth selection (function thumbBw()). Using bw_method=\"cv\" computes cross-validation bandwidth function regCVBwSelC() locpol package (takes longer, especially many covariates). extract bandwidth estimation, run semiiv$bw. Can also specify bw_method = 'plug-' Fan Gijbels (2003), implemented via pluginBw() locpol package (degree local polynomial odd number work). One can also pre-specify bandwidth directly, shown . parameters bwd bandwidth first residual regression YdY_d WdW_d (XX) P̂\\widehat{P}, estimates respectively E[Yd|P]E[Y_d|P], E[Wd|P]E[W_d|P] E[X|P]E[X|P], order get effects semi-IVs potential outcomes. WdW_d XX, order variable depends order specified original formula. sure match variables correct order (careful factor example). One way check first run without specifying bandwidth checking order variables semiiv$estimate$est0 semiiv$estimate$est1. one specifies one value bw0 bw1, applied covariates. bw_y0 bw_y1 bandwidth second part. important since govern smoothness MTE MTR function. Let us check bandwidth previous computation (default rule--thumb method). Re-estimate bandwidth using cross-validation (print_progress=TRUE reporting option see progress function).  Now, illustrate can directly specify bandwidth (adjusts smoothness estimation). Remark: bw_method matter specify bandwidth.  Polynomial degree. One can also specify degree local polynomial estimation pol_degree_locpoly1 pol_degree_locpoly2. Following Fan Gijbels (2003) setting degree equal order derivative function want estimate +1+1, default set pol_degree_locpoly1 = 1 want estimate function directly, pol_degree_locpoly2 = 2 MTE/MTR stage want estimate derivatives control function κd(u)\\kappa_d(u). Propensity Score estimation. One can also extract propensity score estimation. large number observation, fit almost perfect bias due fact PP estimated small.","code":"semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0)) mte_plot = semiiv$plot$mte;  mtr_plot = semiiv$plot$mtr; mtr_plot summary(semiiv$estimate$est0) #>  #> Call: #> lm(formula = formuladx, data = residd) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -3.9165 -0.6515 -0.0026  0.6515  3.7574  #>  #> Coefficients: #>    Estimate Std. Error t value Pr(>|t|)     #> w0 0.797735   0.005537   144.1   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9643 on 24914 degrees of freedom #> Multiple R-squared:  0.4545, Adjusted R-squared:  0.4545  #> F-statistic: 2.076e+04 on 1 and 24914 DF,  p-value: < 2.2e-16 summary(semiiv$estimate$est1); #>  #> Call: #> lm(formula = formuladx, data = residd) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -3.6957 -0.6459 -0.0012  0.6513  3.7204  #>  #> Coefficients: #>    Estimate Std. Error t value Pr(>|t|)     #> w1 0.507895   0.005501   92.33   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9609 on 25084 degrees of freedom #> Multiple R-squared:  0.2536, Adjusted R-squared:  0.2536  #> F-statistic:  8525 on 1 and 25084 DF,  p-value: < 2.2e-16 # To be compared with: param_y0[2]; param_y1[2] #> [1] 0.8 #> [1] 0.5 semiiv$bw #> $bw0 #> [1] 0.05207205 0.04511177 #>  #> $bw1 #> [1] 0.05169498 0.04093002 #>  #> $bw_y0 #> [1] 0.09666612 #>  #> $bw_y1 #> [1] 0.08831236 #>  #> $bw_method #> [1] \"rule-of-thumb\" semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                    bw_method = \"cv\", print_progress=TRUE) #> Estimating first stage... First stage estimated.        #> 2nd stage: Estimating MTR and MTE...  #> D= 0, Robinson 1st residual regression of X on P...                #> Progress: 1/2                              Progress: 2/2                               #> D= 0, Robinson 2nd stage: regression of Y (net of covariates) on P...                #> D= 1, Robinson 1st residual regression of X on P...                #> Progress: 1/2                              Progress: 2/2                               #> D= 1, Robinson 2nd stage: regression of Y (net of covariates) on P...                #> Estimation complete. semiiv$bw #> $bw0 #> [1] 0.46864965 0.08635881 #>  #> $bw1 #> [1] 0.12615761 0.04202802 #>  #> $bw_y0 #> [1] 0.4752831 #>  #> $bw_y1 #> [1] 0.1192076 #>  #> $bw_method #> [1] \"cv\" semiiv = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                    bw0=0.05, bw1=0.05, bw_y0 = 0.2, bw_y1 = 0.2) firststage = semiiv$estimate$propensity # Cannot be compared with param_p directly if V gets rescaled -> but can compare the predicted P with the truth Phat = predict(firststage, newdata=data, type=\"response\")  summary(Phat - data$P) # almost perfect;  #>       Min.    1st Qu.     Median       Mean    3rd Qu.       Max.  #> -0.0045356 -0.0008791  0.0001148  0.0001021  0.0010783  0.0043298"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"semi-iv-sieve-regression","dir":"Articles","previous_headings":"","what":"semi-IV sieve regression","title":"Estimator Performance: general heterogenous treatment effect model","text":"Another approach simply specify flexibly κd(u)\\kappa_d(u), polynomials example, spirit sieve estimation. potentially less flexible (even though still ), advantage faster giving analytical confidence intervals (biased take account fact PP estimated). use estimation method, specify est_method=\"sieve\".  pol_degree_sieve controls flexibility control function used, controlling degree polynomial used. default set 55. Let us compare two estimation methods results.","code":"semiiv2 = semiivreg(y~d|w0|w1, data, ref_indiv = data.frame(w0=0, w1=0),                      est_method=\"sieve\", pol_degree_sieve=5,                      plotting=FALSE)  mte_plot2 = semiiv2$plot$mte; mtr_plot2 = semiiv2$plot$mtr grid.arrange(mte_plot2, mtr_plot2, ncol=2) # If want to plot on the same plot, need some manipulation of the data  dat = semiiv$data$RES # take the original data dat$V = dat$Phat  # for MTE: mte_plot2 = mte_plot2 + geom_line(aes(x=V, y=mte), linetype=\"dashed\", col=\"#db93a4\", na.rm=TRUE, data=dat)   # for MTR need some manipulation dat_plot = dat; dat1 = dat_plot; dat1$mtr = dat_plot$mtr1; dat1$Treatment = 1 dat0 = dat_plot; dat0$mtr = dat_plot$mtr0; dat0$Treatment = 0; dat2 = rbind(dat1, dat0) dat2$Treatment = as.factor(dat2$Treatment)  mtr_plot2 = mtr_plot2 + geom_line(aes(x=V, y=mtr, col=Treatment, group=Treatment), linetype=\"dashed\", na.rm=TRUE, data=dat2)  grid.arrange(mte_plot2, mtr_plot2, ncol=2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"comparison-with-the-truth","dir":"Articles","previous_headings":"","what":"Comparison with the truth","title":"Estimator Performance: general heterogenous treatment effect model","text":"Let us compute ‘true’ underlying MTE. Given model specification, (U0U1)∼N((00),(σU02σU0U1σU0U1σU12)) \\begin{pmatrix} U_0 \\\\ U_1  \\end{pmatrix} \\sim N \\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma_{U_0}^2 & \\sigma_{U_0U_1} \\\\ \\sigma_{U_0U_1} & \\sigma_{U_1}^2 \\end{pmatrix} \\right)  V=−(U1−U0−C) C∼N(0,σC2)⊥(U0,U1). V = - (U_1 - U_0 - C) \\text{ } C \\sim N(0, \\sigma_C^2) \\perp (U_0, U_1).  Simple computation gives V∼N(0,σU02+σU12−2σU0U1+σC2)V \\sim N(0, \\sigma_{U_0}^2 + \\sigma_{U_1}^2 - 2 \\sigma_{U_0U_1} + \\sigma_C^2). Let us introduce UD=FV(V)U_D = F_V(V) uniform normalized VV shock. Now, kd(u)=𝔼[Ud|UD=u]k_d(u) = \\mathbb{E}[U_d | U_D=u]. , kd(u)=𝔼[Ud|V=FV−1(u)]k_d(u) = \\mathbb{E}[U_d | V=F_V^{-1}(u)]. Given specification , VV UdU_d bivariate normal : k0(u)=σU02−σU0U1σV2(FV−1(u)−μV),k1(u)=−σU12+σU0U1σV2(FV−1(u)−μV) \\begin{aligned} k_0(u) &= \\frac{\\sigma_{U_0}^2 - \\sigma_{U_0U_1}}{\\sigma_V^2} \\big(F_{V}^{-1}(u) - \\mu_V \\big), \\\\ k_1(u) &= \\frac{-\\sigma_{U_1}^2 + \\sigma_{U_0U_1}}{\\sigma_V^2} \\big(F_{V}^{-1}(u) - \\mu_V \\big) \\end{aligned}  , true MTR MTE given MTR0(w0,u)=δ0+w0β0+k0(u),MTR1(w1,u)=δ1+w1β1+k1(u),MTE(w0,w1,u)=MTR1(w0,u)−MTR0(w1,u)  \\begin{aligned} MTR_0(w_0, u) &= \\delta_0 + w_0 \\beta_0 +  k_0(u), \\\\ MTR_1(w_1, u) &= \\delta_1 + w_1 \\beta_1 +  k_1(u), \\\\ MTE(w_0, w_1, u) &= MTR_1(w_0, u) - MTR_0(w_1, u) \\end{aligned} Evaluate MTR MTE (w0,w1)=(0,0)(w_0, w_1) = (0, 0).  Overall, see common support, MTE precisely estimated . remarkable exploit parametric knowledge underlying distribution shocks . Compared homogenous treatment effect models, estimation heterogenous treatment effects requires observations. Otherwise, MTE well estimated tails common support. solution just trim estimation set parameters well identified .","code":"# True MTE and MTR estimations  seq_p = seq(0, 1, by=0.001);  w0 = 0; w1 = 0;  sigma_V2 = param_error[1] + param_error[2] - 2*param_error[3] + param_error[4] # = var(V); var(data$V) covU0V = param_error[1] - param_error[3] # = cov(data$U0, data$V) covU1V = -param_error[2] + param_error[3] # = cov(data$U1, data$V) ku0 = covU0V/sigma_V2*(qnorm(seq_p) - 0) # 0 = mean(V) ku1 = covU1V/sigma_V2*(qnorm(seq_p) - 0) # 0 = mean(V) true_mtr0 = param_y0[1] + param_y0[2]*w0 + ku0 true_mtr1 = param_y1[1] + param_y1[2]*w1 + ku1 true_mte = true_mtr1 - true_mtr0  newdata = data.frame(Ud=seq_p, w0=0, w1=0) newdata$true_mte = true_mte; newdata$true_mtr1 = true_mtr1; newdata$true_mtr0 = true_mtr0  ## # Remark: alternative estimation method if the truth does not have a simple closed form formula: ## data$diff = data$y1 - data$y0; pol_degree=5 ## true_model_mte = lm(diff~w1 + w0 + poly(Ud, pol_degree, raw=TRUE), data); # MTE ## true_model_mtr1 = lm(y1 ~w1+poly(Ud, pol_degree, raw=TRUE), data) # MTR1 ## true_model_mtr0 = lm(y0 ~w0+poly(Ud, pol_degree, raw=TRUE), data) # MTR0 ## newdata$true_mte = predict(true_model_mte, newdata);  ## newdata$true_mtr1 = predict(true_model_mtr1, newdata); newdata$true_mtr0 = predict(true_model_mtr0, newdata)   # Comparison: mte_plot2 = mte_plot2 + geom_line(data=newdata, aes(x=Ud, y=true_mte), linetype=\"dashed\", col=\"red\") mtr_plot2 = mtr_plot2 + geom_line(data=newdata, aes(x=Ud, y=true_mtr1), linetype=\"dashed\", col=\"blue\") +   geom_line(data=newdata, aes(x=Ud, y=true_mtr0), linetype=\"dashed\", col=\"orange\")  grid.arrange(mte_plot2, mtr_plot2, ncol=2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_heterogenousTE.html","id":"other-options","dir":"Articles","previous_headings":"","what":"Other options","title":"Estimator Performance: general heterogenous treatment effect model","text":"Trimming Support. seems relatively well estimated, except tails common support entirely satisfied, MTE identified common support. one wants restrict estimation given common support, easy semiivreg().  Post-estimation prediction. Imagine estimating one wants estimate model several individuals. One way directly specify several ref_indiv running initial regression. ’s already estimated, one can simply use semiiv_predict function. also allows predict subset specific values VV.","code":"semiiv1 = semiivreg(y~d|w0|w1, data,                      ref_indiv = data.frame(w0=0, w1=0),                      common_supp_trim = c(0.1, 0.90),                     plotting=FALSE) mte_plot = semiiv1$plot$mte; mtr_plot = semiiv1$plot$mtr; grid.arrange(mtr_plot, mte_plot, ncol=2) newdata = data.frame(w0=seq(-1, 1, by=0.5), w1=0) # Predict the outcome  pred = semiiv_predict(semiiv1, newdata=newdata) head(pred$est) # the predicted values; -> can then be used to redo plots for example.  #>     w0 w1 id  Phat     mtr0     mtr1      mte       k0       k1   delta0X #> 1   -1  0  1 0.100       NA       NA       NA       NA       NA -0.796251 #> 1.1 -1  0  1 0.101 1.920819 3.864864 1.944045 2.717070 3.864864 -0.796251 #> 1.2 -1  0  1 0.102 1.921639 3.859092 1.937453 2.717890 3.859092 -0.796251 #> 1.3 -1  0  1 0.103 1.922464 3.853684 1.931220 2.718715 3.853684 -0.796251 #> 1.4 -1  0  1 0.104 1.923289 3.848410 1.925120 2.719540 3.848410 -0.796251 #> 1.5 -1  0  1 0.105 1.924108 3.843222 1.919114 2.720359 3.843222 -0.796251 #>     delta1X  se_delta0X se_delta1X #> 1         0 0.005683472          0 #> 1.1       0 0.005683472          0 #> 1.2       0 0.005683472          0 #> 1.3       0 0.005683472          0 #> 1.4       0 0.005683472          0 #> 1.5       0 0.005683472          0 pred$deltaX # provides the shift in effect of X and Wd -> may be the only thing we care about, know that shifts the curve #>     w0 w1 id    delta0X delta1X  se_delta0X se_delta1X #> 1 -1.0  0  1 -0.7962510       0 0.005683472          0 #> 2 -0.5  0  2 -0.3981255       0 0.002841736          0 #> 3  0.0  0  3  0.0000000       0 0.000000000          0 #> 4  0.5  0  4  0.3981255       0 0.002841736          0 #> 5  1.0  0  5  0.7962510       0 0.005683472          0"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"simulating-data","dir":"Articles","previous_headings":"","what":"Simulating data","title":"Estimator Performance: homogenous treatment effect model","text":"simulate generalized Roy models using simul_data()function. See documentation function details model. Depending chosen parameters, can simulate model homogenous/heterogenous treatment effects, well valid IVs eventually. ’s . every simulation include covariates (set effect 0), can easily included.","code":""},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"simulate-data","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Simulate data","title":"Estimator Performance: homogenous treatment effect model","text":"model homogenous Treatment Effects (conditional W0,W1W_0, W_1).","code":"# Model 1 library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.5, 0.5, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"true-unobserved-homogenous-treatment-effects","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"True unobserved homogenous Treatment Effects","title":"Estimator Performance: homogenous treatment effect model","text":", (W0,W1)=(0,0)(W_0, W_1) = (0, 0), effect always 0.4 (see parameters). see , let us just use true unobserved potential outcomes (observed thanks simulation). true model like recover. Note perfect fit exactly error term potential outcomes, U0=U1=UU_0 = U_1 = U. additional error term uncorrelated rest, estimate coefficients (noise).","code":"data$true_TE = data$y1 - data$y0 summary(lm(true_TE ~ w0 + w1, data)) #>  #> Call: #> lm(formula = true_TE ~ w0 + w1, data = data) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -5.753e-13 -1.600e-16  5.000e-17  2.700e-16  1.548e-13  #>  #> Coefficients: #>               Estimate Std. Error            t value Pr(>|t|)     #> (Intercept)  4.000e-01  6.099e-17   6558145526539307   <2e-16 *** #> w0          -8.000e-01  6.196e-17 -12911565410646968   <2e-16 *** #> w1           5.000e-01  6.226e-17   8030568306192379   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 6.099e-15 on 9997 degrees of freedom #> Multiple R-squared:      1,  Adjusted R-squared:      1  #> F-statistic: 8.343e+31 on 2 and 9997 DF,  p-value: < 2.2e-16 true_param = c(param_y0[1], param_y1[1] - param_y0[1], param_y0[2], param_y1[2]); true_param #> [1] 3.2 0.4 0.8 0.5 # constant y0, constant y1 - constant y0, effects of w0 on y0, effects of w1 on y1."},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"naive-ols","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Naive OLS","title":"Estimator Performance: homogenous treatment effect model","text":"Obviously, naive OLS estimator biased, endogeneity: UU correlated DD YY. overestimates effect treatment DD 1. individuals high UU select themself D=1D=1 higher YY. Indeed E(U|D=1)>E(U|D=0)E(U | D=1) > E(U | D=0), UU negatively correlated VV (cf covariance parameter param_error), higher UU, lower VV, lower VV, likely one select D=1D=1.","code":"naive_ols = lm(y ~ d + w0 + w1, data); summary(naive_ols) #>  #> Call: #> lm(formula = y ~ d + w0 + w1, data = data) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -4.0776 -0.6767  0.0018  0.6924  3.9086  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  2.70023    0.01464  184.47   <2e-16 *** #> d            1.17707    0.02126   55.37   <2e-16 *** #> w0           0.28488    0.01068   26.66   <2e-16 *** #> w1           0.36167    0.01075   33.66   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.008 on 9996 degrees of freedom #> Multiple R-squared:   0.45,  Adjusted R-squared:  0.4498  #> F-statistic:  2726 on 3 and 9996 DF,  p-value: < 2.2e-16 mean(data$U1[which(data$d == 1)]); mean(data$U0[which(data$d==0)]) #> [1] 0.3521838 #> [1] -0.3516911"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"wrongly-assuming-that-the-semi-ivs-are-valid-ivs","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Wrongly assuming that the semi-IVs are valid IVs","title":"Estimator Performance: homogenous treatment effect model","text":"assume W0W_0 W1W_1 valid IVs (.e., direct effect respective potential outcomes)? estimated coefficients also completely biased , assumes semi-IVs effect outcomes .","code":"library(ivreg) # remark: ivreg is not required otherwise in semiivreg, only in this vignette.  valid_iv = ivreg(y ~ d | w0 + w1 + w0:w1, data=data); summary(valid_iv) #>  #> Call: #> ivreg(formula = y ~ d | w0 + w1 + w0:w1, data = data) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -5.42133 -0.82741  0.01821  0.83379  4.51746  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  2.85027    0.04109   69.37   <2e-16 *** #> d            0.88099    0.07832   11.25   <2e-16 *** #>  #> Diagnostic tests: #>                   df1  df2 statistic  p-value     #> Weak instruments    3 9996    371.29  < 2e-16 *** #> Wu-Hausman          1 9997     12.88 0.000333 *** #> Sargan              2   NA   3268.63  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.24 on 9998 degrees of freedom #> Multiple R-Squared: 0.1681,  Adjusted R-squared: 0.1681  #> Wald test: 126.5 on 1 and 9998 DF,  p-value: < 2.2e-16"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"semi-iv-estimation-with-semiivreg","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"semi-IV estimation with semiivreg","title":"Estimator Performance: homogenous treatment effect model","text":"Let us now see semi-IV estimator performs. specify estimation homogenous treatment effects, specify est_method=\"homogenous\". performs sieve-like estimation additional constraint restrict MTE constant imposing constraints control function κ0(p)\\kappa_0(p) κ1(p)\\kappa_1(p). estimated coefficients close truth, relatively small standard errors , even though sample size modest (10000 observations). cautious though: standard errors computed without taking account fact propensity score estimated first stage. can correct estimation semiivreg_boot(). typically, first stage well estimated, bias standard errors small, visible .","code":"semiiv = semiivreg(y~d|w0|w1, data, est_method=\"homogenous\", plotting=FALSE) summary_coeff = semiiv$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate  Std_Error   t_value           p_value #> 1 (Intercept) 3.2058476 0.03386160 94.675015 0.000000000000000 #> 2        I(d) 0.3890825 0.06510590  5.976149 0.000000002362833 #> 3 I(1 - d):w0 0.8029398 0.01191954 67.363298 0.000000000000000 #> 4     I(d):w1 0.4972506 0.01185955 41.928280 0.000000000000000 true_param #> [1] 3.2 0.4 0.8 0.5 semiivboot = semiivreg_boot(y~d|w0|w1, data, Nboot=200, est_method=\"homogenous\", plotting=FALSE) # reduce the number of bootstrap simulation for speed;   #> Bandwidth and MTR/MTE estimation on main sample... Bandwidth and MTR/MTE estimation on main sample: Done.  #> Bootstrap Progress: 1/200 Bootstrap Progress: 2/200 Bootstrap Progress: 3/200 Bootstrap Progress: 4/200 Bootstrap Progress: 5/200 Bootstrap Progress: 6/200 Bootstrap Progress: 7/200 Bootstrap Progress: 8/200 Bootstrap Progress: 9/200 Bootstrap Progress: 10/200 Bootstrap Progress: 11/200 Bootstrap Progress: 12/200 Bootstrap Progress: 13/200 Bootstrap Progress: 14/200 Bootstrap Progress: 15/200 Bootstrap Progress: 16/200 Bootstrap Progress: 17/200 Bootstrap Progress: 18/200 Bootstrap Progress: 19/200 Bootstrap Progress: 20/200 Bootstrap Progress: 21/200 Bootstrap Progress: 22/200 Bootstrap Progress: 23/200 Bootstrap Progress: 24/200 Bootstrap Progress: 25/200 Bootstrap Progress: 26/200 Bootstrap Progress: 27/200 Bootstrap Progress: 28/200 Bootstrap Progress: 29/200 Bootstrap Progress: 30/200 Bootstrap Progress: 31/200 Bootstrap Progress: 32/200 Bootstrap Progress: 33/200 Bootstrap Progress: 34/200 Bootstrap Progress: 35/200 Bootstrap Progress: 36/200 Bootstrap Progress: 37/200 Bootstrap Progress: 38/200 Bootstrap Progress: 39/200 Bootstrap Progress: 40/200 Bootstrap Progress: 41/200 Bootstrap Progress: 42/200 Bootstrap Progress: 43/200 Bootstrap Progress: 44/200 Bootstrap Progress: 45/200 Bootstrap Progress: 46/200 Bootstrap Progress: 47/200 Bootstrap Progress: 48/200 Bootstrap Progress: 49/200 Bootstrap Progress: 50/200 Bootstrap Progress: 51/200 Bootstrap Progress: 52/200 Bootstrap Progress: 53/200 Bootstrap Progress: 54/200 Bootstrap Progress: 55/200 Bootstrap Progress: 56/200 Bootstrap Progress: 57/200 Bootstrap Progress: 58/200 Bootstrap Progress: 59/200 Bootstrap Progress: 60/200 Bootstrap Progress: 61/200 Bootstrap Progress: 62/200 Bootstrap Progress: 63/200 Bootstrap Progress: 64/200 Bootstrap Progress: 65/200 Bootstrap Progress: 66/200 Bootstrap Progress: 67/200 Bootstrap Progress: 68/200 Bootstrap Progress: 69/200 Bootstrap Progress: 70/200 Bootstrap Progress: 71/200 Bootstrap Progress: 72/200 Bootstrap Progress: 73/200 Bootstrap Progress: 74/200 Bootstrap Progress: 75/200 Bootstrap Progress: 76/200 Bootstrap Progress: 77/200 Bootstrap Progress: 78/200 Bootstrap Progress: 79/200 Bootstrap Progress: 80/200 Bootstrap Progress: 81/200 Bootstrap Progress: 82/200 Bootstrap Progress: 83/200 Bootstrap Progress: 84/200 Bootstrap Progress: 85/200 Bootstrap Progress: 86/200 Bootstrap Progress: 87/200 Bootstrap Progress: 88/200 Bootstrap Progress: 89/200 Bootstrap Progress: 90/200 Bootstrap Progress: 91/200 Bootstrap Progress: 92/200 Bootstrap Progress: 93/200 Bootstrap Progress: 94/200 Bootstrap Progress: 95/200 Bootstrap Progress: 96/200 Bootstrap Progress: 97/200 Bootstrap Progress: 98/200 Bootstrap Progress: 99/200 Bootstrap Progress: 100/200 Bootstrap Progress: 101/200 Bootstrap Progress: 102/200 Bootstrap Progress: 103/200 Bootstrap Progress: 104/200 Bootstrap Progress: 105/200 Bootstrap Progress: 106/200 Bootstrap Progress: 107/200 Bootstrap Progress: 108/200 Bootstrap Progress: 109/200 Bootstrap Progress: 110/200 Bootstrap Progress: 111/200 Bootstrap Progress: 112/200 Bootstrap Progress: 113/200 Bootstrap Progress: 114/200 Bootstrap Progress: 115/200 Bootstrap Progress: 116/200 Bootstrap Progress: 117/200 Bootstrap Progress: 118/200 Bootstrap Progress: 119/200 Bootstrap Progress: 120/200 Bootstrap Progress: 121/200 Bootstrap Progress: 122/200 Bootstrap Progress: 123/200 Bootstrap Progress: 124/200 Bootstrap Progress: 125/200 Bootstrap Progress: 126/200 Bootstrap Progress: 127/200 Bootstrap Progress: 128/200 Bootstrap Progress: 129/200 Bootstrap Progress: 130/200 Bootstrap Progress: 131/200 Bootstrap Progress: 132/200 Bootstrap Progress: 133/200 Bootstrap Progress: 134/200 Bootstrap Progress: 135/200 Bootstrap Progress: 136/200 Bootstrap Progress: 137/200 Bootstrap Progress: 138/200 Bootstrap Progress: 139/200 Bootstrap Progress: 140/200 Bootstrap Progress: 141/200 Bootstrap Progress: 142/200 Bootstrap Progress: 143/200 Bootstrap Progress: 144/200 Bootstrap Progress: 145/200 Bootstrap Progress: 146/200 Bootstrap Progress: 147/200 Bootstrap Progress: 148/200 Bootstrap Progress: 149/200 Bootstrap Progress: 150/200 Bootstrap Progress: 151/200 Bootstrap Progress: 152/200 Bootstrap Progress: 153/200 Bootstrap Progress: 154/200 Bootstrap Progress: 155/200 Bootstrap Progress: 156/200 Bootstrap Progress: 157/200 Bootstrap Progress: 158/200 Bootstrap Progress: 159/200 Bootstrap Progress: 160/200 Bootstrap Progress: 161/200 Bootstrap Progress: 162/200 Bootstrap Progress: 163/200 Bootstrap Progress: 164/200 Bootstrap Progress: 165/200 Bootstrap Progress: 166/200 Bootstrap Progress: 167/200 Bootstrap Progress: 168/200 Bootstrap Progress: 169/200 Bootstrap Progress: 170/200 Bootstrap Progress: 171/200 Bootstrap Progress: 172/200 Bootstrap Progress: 173/200 Bootstrap Progress: 174/200 Bootstrap Progress: 175/200 Bootstrap Progress: 176/200 Bootstrap Progress: 177/200 Bootstrap Progress: 178/200 Bootstrap Progress: 179/200 Bootstrap Progress: 180/200 Bootstrap Progress: 181/200 Bootstrap Progress: 182/200 Bootstrap Progress: 183/200 Bootstrap Progress: 184/200 Bootstrap Progress: 185/200 Bootstrap Progress: 186/200 Bootstrap Progress: 187/200 Bootstrap Progress: 188/200 Bootstrap Progress: 189/200 Bootstrap Progress: 190/200 Bootstrap Progress: 191/200 Bootstrap Progress: 192/200 Bootstrap Progress: 193/200 Bootstrap Progress: 194/200 Bootstrap Progress: 195/200 Bootstrap Progress: 196/200 Bootstrap Progress: 197/200 Bootstrap Progress: 198/200 Bootstrap Progress: 199/200 Bootstrap Progress: 200/200  boot_se = semiivboot$estimate$coeff$std_error[1:4] res = as.data.frame(cbind(summary_coeff[1:4,1:3], boot_se)); colnames(res) = c(\"Variable\", \"Estimate\", \"wrong analytic SE\", \"Bootstrapped SE\") res #>      Variable  Estimate wrong analytic SE Bootstrapped SE #> 1 (Intercept) 3.2058476        0.03386160      0.03480909 #> 2        I(d) 0.3890825        0.06510590      0.06576680 #> 3 I(1 - d):w0 0.8029398        0.01191954      0.01389785 #> 4     I(d):w1 0.4972506        0.01185955      0.01250709"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/semiIVreg_homogenousTE.html","id":"alternative-semi-iv-strategy-based-on-iv-quantile-regression","dir":"Articles","previous_headings":"Model with homogenous treatment effects","what":"Alternative semi-IV strategy: based on IV-quantile regression","title":"Estimator Performance: homogenous treatment effect model","text":"described Bruneel-Zupanc (2024), another general nonparametric identification strategy semi-IV, building IV-quantile regression (IVQR) framework Chernozhukov Hansen (2005). model homogenous treatment effect, strategy requires interaction W0×W1W_0 \\times W_1 relevant selection treatment. intuition interaction now serves IV treatment DD within framework. nice feature strategy can implemented standard IV estimation, e.g., ivreg() R. baseline model, interaction significant first stage, problem weak IVs. case baseline model, estimation blow IV irrelevant. However, specify alternative model interaction indeed relevant, also estimate correctly homogenous treatment effect using strategy. now. model param_p[4] gives effect W0×W1W_0\\times W_1 DD. different 0 . IVQR strategy work. Indeed, estimates coefficients well. Notice semiivreg() function also works : Thus semiivreg()flexible used case. Notice , general IVQR estimation also higher variance estimate builds interaction IV requires large significant effects treatment avoid weak IV concerns. semiivreg() relies fact semi-IV relevant , relatively easier satisfy. Especially semi-IVs strong impact respective potential outcome, relevant soon selection treatment based gains (.e., Y1−Y0Y_1 - Y_0). Remark: since know first stage includes interaction, might well include semiivreg follows (previous results including still ok, despite bias prediction propensity score wrong formula)","code":"semiivqr = ivreg(y~d+I(1-d):w0 + I(d):w1|w0+w1+w0:w1, data=data) summary(semiivqr) #> Warning in printHypothesis(L, rhs, names(b)): one or more coefficients in the hypothesis include #>      arithmetic operators in their names; #>   the printed representation of the hypothesis will be omitted #>  #> Call: #> ivreg(formula = y ~ d + I(1 - d):w0 + I(d):w1 | w0 + w1 + w0:w1,  #>     data = data) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.315219 -0.647210 -0.002237  0.644122  3.580389  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)   2.9539     0.8646   3.417 0.000637 *** #> d             0.8944     1.7323   0.516 0.605655     #> I(1 - d):w0   0.6523     0.5202   1.254 0.209907     #> I(d):w1       0.6460     0.4998   1.293 0.196159     #>  #> Diagnostic tests: #>                                 df1  df2 statistic p-value     #> Weak instruments (d)              3 9996    371.29  <2e-16 *** #> Weak instruments (I(1 - d):w0)    3 9996   3228.13  <2e-16 *** #> Weak instruments (I(d):w1)        3 9996   3503.39  <2e-16 *** #> Wu-Hausman                        3 9993     46.22  <2e-16 *** #> Sargan                            0   NA        NA      NA     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.9535 on 9996 degrees of freedom #> Multiple R-Squared: 0.5082,  Adjusted R-squared: 0.5081  #> Wald test:  1914 on 3 and 9996 DF,  p-value: < 2.2e-16 # Model 2 N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.3, 0.4, 0.3, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous)  data2 = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error) semiivqr2 = ivreg(y~d+I(1-d):w0 + I(d):w1|w0+w1+w0:w1, data=data2); summary(semiivqr2) #> Warning in printHypothesis(L, rhs, names(b)): one or more coefficients in the hypothesis include #>      arithmetic operators in their names; #>   the printed representation of the hypothesis will be omitted #>  #> Call: #> ivreg(formula = y ~ d + I(1 - d):w0 + I(d):w1 | w0 + w1 + w0:w1,  #>     data = data2) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.611960 -0.676872 -0.003606  0.669898  3.886447  #>  #> Coefficients: #>             Estimate Std. Error t value  Pr(>|t|)     #> (Intercept)  3.21013    0.03615  88.811   < 2e-16 *** #> d            0.37626    0.08777   4.287 0.0000183 *** #> I(1 - d):w0  0.80317    0.01516  52.976   < 2e-16 *** #> I(d):w1      0.49653    0.04179  11.882   < 2e-16 *** #>  #> Diagnostic tests: #>                                 df1  df2 statistic p-value     #> Weak instruments (d)              3 9996    405.38  <2e-16 *** #> Weak instruments (I(1 - d):w0)    3 9996   8024.23  <2e-16 *** #> Weak instruments (I(d):w1)        3 9996   1676.42  <2e-16 *** #> Wu-Hausman                        3 9993     50.75  <2e-16 *** #> Sargan                            0   NA        NA      NA     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 1.005 on 9996 degrees of freedom #> Multiple R-Squared: 0.4829,  Adjusted R-squared: 0.4828  #> Wald test:  2101 on 3 and 9996 DF,  p-value: < 2.2e-16 semiiv2 = semiivreg(y~d|w0|w1, data=data2, est_method=\"homogenous\", plotting=FALSE) summary_coeff2 = semiiv2$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff2[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate  Std_Error  t_value       p_value #> 1 (Intercept) 3.2053784 0.04084850 78.46991  0.000000e+00 #> 2        I(d) 0.3868430 0.09585951  4.03552  5.488775e-05 #> 3 I(1 - d):w0 0.8048831 0.00960523 83.79634  0.000000e+00 #> 4     I(d):w1 0.5004888 0.01866240 26.81803 4.784644e-153 true_param #> [1] 3.2 0.4 0.8 0.5 semiiv3 = semiivreg(y~d|w0|w1, propensity_formula = d~w0+w1+w0:w1,                      data=data2, est_method=\"homogenous\", plotting=FALSE) fstage = semiiv3$estimate$propensity; summary(fstage) # returns the first stage estimation #>  #> Call: #> glm(formula = propensity_formula, family = binomial(link = \"probit\"),  #>     data = propensity_data) #>  #> Coefficients: #>             Estimate Std. Error z value Pr(>|z|)     #> (Intercept) -0.02004    0.01483  -1.351    0.177     #> w0           0.24314    0.01391  17.475   <2e-16 *** #> w1          -0.32813    0.01424 -23.043   <2e-16 *** #> w0:w1       -0.23864    0.01014 -23.535   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 13620  on 9999  degrees of freedom #> Residual deviance: 12366  on 9996  degrees of freedom #> AIC: 12374 #>  #> Number of Fisher Scoring iterations: 4 summary_coeff3 = semiiv3$estimate$est # extract the coefficients from the homogenous TE specification summary_coeff3[1:4,] # only print the first 4 coefficients, the other correspond to the control function of P #>      Variable  Estimate   Std_Error    t_value       p_value #> 1 (Intercept) 3.2071842 0.027427671 116.932429  0.000000e+00 #> 2        I(d) 0.3847556 0.061775953   6.228242  4.906916e-10 #> 3 I(1 - d):w0 0.8032558 0.009526755  84.315781  0.000000e+00 #> 4     I(d):w1 0.5013325 0.015732198  31.866653 2.577489e-212 true_param #> [1] 3.2 0.4 0.8 0.5"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"the-generalized-roy-model","dir":"Articles","previous_headings":"","what":"The Generalized Roy Model","title":"Simulating Generalized Roy Models","text":"function simulates generalized Roy model described Bruneel-Zupanc (2024). Potential Outcomes. potential outcomes (e.g., earnings) given : Y0=δ0+β0W0+Xβ0X+U0, Y_0 = \\delta_{0} + \\beta_{0} W_0 + X \\beta_{0X} + U_0, Y1=δ1+β1W1+Xβ1X+U1, Y_1 = \\delta_{1} + \\beta_{1} W_1 + X \\beta_{1X} + U_1, W0,W1W_0, W_1 observed semi-IVs excluded Y1Y_1 Y0Y_0 respectively, X=(X1,X2)X=(X_1, X_2) vector binary (X1X_1, e.g., location) continuous (X2X_2, e.g., education parents) observable covariates, U0,U1U_0, U_1 unobservable errors. Selection Problem. observe outcome Y=(1−D)Y0+DY1. Y = (1-D) Y_0 + D Y_1. DD represents (binary) treatment decision (e.g., education choice), given following selection rule: D*=g(W0,W1,X)−V=−(α+α0W0+α1W1+α2W0×W1+αX1X1+αX2X2)−V, D=𝕀(D*>0), \\begin{aligned} D^* &= g(W_0, W_1, X) - V \\\\ &= - ( \\alpha + \\alpha_0 W_0 + \\alpha_1 W_1 + \\alpha_2 W_0 \\times W_1 + \\alpha_{X_1} X_1 + \\alpha_{X_2} X_2) - V, \\\\ \\text{ } \\quad D &= \\mathbb{}(D^* > 0), \\end{aligned} VV main unobservable probability shock, higher VV, likely one treated. Note normalize UD=FV(V)U_D=F_{V}(V) get normalized probability shock UD∼𝒰(0,1)U_D \\sim \\mathcal{U}(0, 1). UDU_D can interpreted unobserved resistance treatment. closer UDU_D 0, likely individual treated. specification yields probability treatment given : Pr(D=1|W0,W1,X)=Pr(V<g(W0,W1,X)). \\textrm{Pr}(D=1 | W_0, W_1, X) = \\textrm{Pr}(V < g(W_0, W_1, X)). Thus, ceteris paribus, lower gg, higher probability treatment.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"unobservables-specification","dir":"Articles","previous_headings":"The Generalized Roy Model","what":"Unobservables specification","title":"Simulating Generalized Roy Models","text":"specification unobservable depends model type.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"heterogenous-treatment-effects","dir":"Articles","previous_headings":"The Generalized Roy Model > Unobservables specification","what":"Heterogenous treatment effects","title":"Simulating Generalized Roy Models","text":"general heterogeneous treatment effect model, : (U0U1)∼𝒩((00),(σU02σU0U1σU0U1σU12)), \\begin{pmatrix} U_0 \\\\ U_1 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{U0} & \\sigma_{U0U1} \\\\ \\sigma_{U0U1} & \\sigma^2_{U1} \\end{pmatrix} \\right), C∼𝒩(μcost,σcost2), C \\sim \\mathcal{N}(\\mu_{\\text{cost}}, \\sigma^2_{\\text{cost}}), V=−(U1−U0−C). V = -(U_1 - U_0 - C). Note specification simulates dataset roydata dataset available package, can loaded using data(roydata).","code":"library(semiIVreg) #> KernSmooth 2.23 loaded #> Copyright M. P. Wand 1997-2009 #> Loading required package: zoo #>  #> Attaching package: 'zoo' #> The following objects are masked from 'package:data.table': #>  #>     yearmon, yearqtr #> The following objects are masked from 'package:base': #>  #>     as.Date, as.Date.numeric # Example of general model with heterogenous treatment effects N = 100000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"homogenous-treatment-effect","dir":"Articles","previous_headings":"The Generalized Roy Model > Unobservables specification","what":"Homogenous treatment effect","title":"Simulating Generalized Roy Models","text":"restricted homogeneous treatment effect model: (UV)∼𝒩((0μV),(σU2σUVσUVσV2)), \\begin{pmatrix} U \\\\ V \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ \\mu_{V} \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{U} & \\sigma_{UV} \\\\ \\sigma_{UV} & \\sigma^2_{V} \\end{pmatrix} \\right), U0=U1=U. U_0 = U_1 = U. cases, VV normally distributed, selection equation probit model. Covariates Semi-IVs Specification. covariates generated X1∼Bernoulli(pX1) X2∼𝒩(μX2,σX22). X_1 \\sim \\text{Bernoulli}(p_{X_1}) \\text{ } X_2 \\sim \\mathcal{N}(\\mu_{X_2}, \\sigma^2_{X_2}). semi-IVs X1X_1-specific given : (W0W1)∼𝒩((μW0,x1μW1,x1),(σW02σW0W1σW0W1σW12)), \\begin{pmatrix} W_0 \\\\ W_1 \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} \\mu_{W0,x_1} \\\\ \\mu_{W1,x_1} \\end{pmatrix}, \\begin{pmatrix} \\sigma^2_{W0} & \\sigma_{W0W1} \\\\ \\sigma_{W0W1} & \\sigma^2_{W1} \\end{pmatrix} \\right), means μW0,x1\\mu_{W0,x_1} μW1,x1\\mu_{W1,x_1} depend binary covariate X1=x1X_1=x_1. function used simulate dataset roydata2 available package, can loaded using data(roydata2).","code":"# Model with homogenous treatment effects - not the same param_error to specify.  library(semiIVreg) N = 10000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv # if homogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.5, 0.5, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0.8, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2) # probability state=1 (instead of 0), mean_parenteduc, sd_parenteduc (parenteduc drawn as continuous)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/articles/simul_data.html","id":"simulating-standard-iv-mte-models","dir":"Articles","previous_headings":"","what":"Simulating Standard IV MTE Models","title":"Simulating Generalized Roy Models","text":"function can used model problems IVs used estimate Marginal Treatment Effects, setting effect semi-IVs respective outcomes zero. coefficients can adjusted mimic Roy models James J. Heckman, Urzua, Vytlacil (2006), James J. Heckman Vytlacil (2007). Small adjustments inside function allow mimicking simulation (andresen2018?) (mtefe Stata), 2 regions (state).","code":"# Example of generalized Roy Model where the semi-IVs are valid IVs N = 50000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost (the mean cost = constant in D*) # if heterogenous param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 state0, meanW1 state0, meanW0 state1, meanW1 state1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, alphaW0, alphaW1, alphaW0W1, effect of state, effect of parent educ param_y0 = c(3.2, 0, 0, 0) # intercept, effect of Wd, effect of state, effect of parent educ; param_y1 = c(3.2+0.4, 0, 0, 0) # the +0.2 = Average treatment effect; effect of W1, effect of state, effect of parent educ; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)  param_y0[2]; # W0 is a valid IV because no direct effect on Y0 #> [1] 0 param_y1[2] # W1 is a valid IV because no direct effect on Y1 #> [1] 0"},{"path":[]},{"path":"https://cbruneelzupanc.github.io/semiIVreg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christophe Bruneel. Author, maintainer.            https://cbruneel.com","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bruneel C (2024). semiIVreg: Semi-Instrumental Variable (semi-IV) Regression. R package version 1.0.0, https://cbruneelzupanc.github.io/semiIVreg/, https://www.cbruneel.com/.","code":"@Manual{,   title = {semiIVreg: Semi-Instrumental Variable (semi-IV) Regression},   author = {Christophe Bruneel},   year = {2024},   note = {R package version 1.0.0, https://cbruneelzupanc.github.io/semiIVreg/},   url = {https://www.cbruneel.com/}, }"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"semiivreg-r-package-for-semi-iv-regression","dir":"","previous_headings":"","what":"Semi-Instrumental Variable (semi-IV) Regression","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"package provides implementation semi-IV regressions described Bruneel-Zupanc (2024).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"can find development version semiIVreg GitHub. can download install directly local source computer: Alternatively, can directly download GitHub repository:","code":"# If the package is in a .tar.gz file install.packages(\"/path/to/your/package.tar.gz\", repos = NULL, type = \"source\")  # If the package is in a directory install.packages(\"/path/to/your/package_directory\", repos = NULL, type = \"source\") # install.packages(\"devtools\") devtools::install_github(\"cbruneelzupanc/semiIVreg\")"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/index.html","id":"semi-iv-regression","dir":"","previous_headings":"","what":"Semi-IV Regression","title":"Semi-Instrumental Variable (semi-IV) Regression","text":"illustrates semiivreg()command reports semi-IV regression. default, reports common support plot propensity score estimated marginal treatment effects (MTE).  One can also easily extract plot marginal treatment responses (MTR):  details, see detailed documentation function detailed vignettes.","code":"library(semiIVreg) ## KernSmooth 2.23 loaded ## Copyright M. P. Wand 1997-2009 data(roydata) # load the data from a simulated Roy model  # semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata, est_method=\"sieve\") semiiv$plot$mtr"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Control functions transformations for selection probabilities — Kappa_fun","title":"Control functions transformations for selection probabilities — Kappa_fun","text":"functions provides pre-specified transformations control flexibly selection probabilities regression.  correspond \\(\\kappa_d(p)\\) corresponding \\(k_d(u)\\) Bruneel-Zupanc (2024).  Special functions used homogenous treatment effect specifications code different. July 2024: now, polynomial transformations encoded.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control functions transformations for selection probabilities — Kappa_fun","text":"","code":"Kappa_fun(p, pol_degree = 5)  kdu_transform_fun(u, d, pol_degree = 5)  Kappa_homogenous_fun(p, pol_degree = 5)  ku_transform_homogenous_fun(u, pol_degree = 5)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control functions transformations for selection probabilities — Kappa_fun","text":"p Vector propensity scores transform flexible function. pol_degree Degree polynomial transformation. d potential outcome consider (needed \\(k_d(u)\\) heterogenous treatment effects).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control functions transformations for selection probabilities — Kappa_fun","text":"See Andresen (2018) Bruneel-Zupanc (2024) computation details linking \\(\\kappa_d(p)\\) corresponding corresponding \\(k_d(u)\\).  \\(\\kappa_1(p) = E(U_1 | U_D \\leq p) \\) \\(\\kappa_0(p) = E(U_0 | U_D>p) \\) \\(k_d(u) = E(U_d | U_D=u)\\). case homogenous treatment effects: \\(k_0(u) = k_1(u)\\). provides restriction \\(\\kappa\\), hence special functions.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/Kappa_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control functions transformations for selection probabilities — Kappa_fun","text":"","code":"v = seq(0.1, 0.9, by=0.1) # Transformations for general Heterogenous TE functions: Kappa_fun(p=v, pol_degree=6) #>         1    2     3      4       5        6 #>  [1,] 0.1 0.01 0.001 0.0001 0.00001 0.000001 #>  [2,] 0.2 0.04 0.008 0.0016 0.00032 0.000064 #>  [3,] 0.3 0.09 0.027 0.0081 0.00243 0.000729 #>  [4,] 0.4 0.16 0.064 0.0256 0.01024 0.004096 #>  [5,] 0.5 0.25 0.125 0.0625 0.03125 0.015625 #>  [6,] 0.6 0.36 0.216 0.1296 0.07776 0.046656 #>  [7,] 0.7 0.49 0.343 0.2401 0.16807 0.117649 #>  [8,] 0.8 0.64 0.512 0.4096 0.32768 0.262144 #>  [9,] 0.9 0.81 0.729 0.6561 0.59049 0.531441 #> attr(,\"degree\") #> [1] 1 2 3 4 5 6 #> attr(,\"class\") #> [1] \"poly\"   \"matrix\" k1u = kdu_transform_fun(v, d=1, pol_degree=6)  # Transformations for Homogenous TE functions: Kappa_homogenous_fun(p=v, pol_degree=6) #>       const   1    2     3      4       5        6 #>  [1,]     1 0.1 0.01 0.001 0.0001 0.00001 0.000001 #>  [2,]     1 0.2 0.04 0.008 0.0016 0.00032 0.000064 #>  [3,]     1 0.3 0.09 0.027 0.0081 0.00243 0.000729 #>  [4,]     1 0.4 0.16 0.064 0.0256 0.01024 0.004096 #>  [5,]     1 0.5 0.25 0.125 0.0625 0.03125 0.015625 #>  [6,]     1 0.6 0.36 0.216 0.1296 0.07776 0.046656 #>  [7,]     1 0.7 0.49 0.343 0.2401 0.16807 0.117649 #>  [8,]     1 0.8 0.64 0.512 0.4096 0.32768 0.262144 #>  [9,]     1 0.9 0.81 0.729 0.6561 0.59049 0.531441 ku = ku_transform_homogenous_fun(v, pol_degree=6) # no d anymore, same for both d here;"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Data construction functions — construct_data","title":"Data construction functions — construct_data","text":"functions used construct data given formula. Handles change factor several dummies example. also create reference individuals evaluate MTE MTR (default provided). numerical variables, take average variable; factors, take first level.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data construction functions — construct_data","text":"","code":"construct_data(formula, data)  transform_factor(formula, data)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/construct_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data construction functions — construct_data","text":"formula formula model data original dataset","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"MTE and MTR sub-estimation functions — mtr_est_poly","title":"MTE and MTR sub-estimation functions — mtr_est_poly","text":"functions allow estimate mte mtr, confidence intervals, based coefficients estimated main model main function. details can found Bruneel-Zupanc (2024).  Different formulas must applied depending whether treatment homogenous heterogenous.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MTE and MTR sub-estimation functions — mtr_est_poly","text":"","code":"mtr_est_poly(d, data, seq_u,                     bwd = NULL, bw_y = NULL, bw_method = \"plug-in\",                     pol_degree1, pol_degree2,                     var_outcome, var_treatment, var_w0, var_w1, var_covariates,                     print_progress)  mtr_fun_poly(ref_indiv, eval_v, est0, est1, k0, k1, se_type)  lpoly_regress(x, y, bw=NULL, bw_method=\"plug-in\", degree, drv)  mtr_coeff(coeff, vcov, var_cov_2nd, est_method=\"sieve\")  mtr_est(coeff, vcov, names_var, df)  mtr_predict_sieve(coeff, vcov, ref_indiv, var_treatment, var_cov_2nd, pol_degree, seq_u, t_value, est_method, se_type)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MTE and MTR sub-estimation functions — mtr_est_poly","text":"seq_u Sequence v compute prediction kd(v). bw_method Method compute bandwidth (bandwdith NULL) ref_indiv Newdata (reference individuals) compute predictions. x Vector x values y Vector y values bw Pre-specified bandwidth degree Degree polynomial: recommended set drv + 1 drv Derivative order function estimated. coeff Vector (stacked) coefficients mtr0, mtr1. vcov Covariance matrix coefficients. est_method Either \"sieve\" \"homogenous\". names_var Names variables corresponding coefficients. df Degrees freedom p-values. var_cov_2nd Names covariates semi-IVs","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MTE and MTR sub-estimation functions — mtr_est_poly","text":"Returns raw (stacked regression) coefficients covariance matrix corresponding mtr0, mtr1 mte function. Returns mtr0, mtr1 mte estimates tables standard errors p-values. Also exports corresponding estimates vcov matrices. Returns mtr0, mtr1, mte estimates confidence intervals specified ref_indiv.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal Treatment Effect (MTE) and Responses (MTR) plots — mtr_plot_fun","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots — mtr_plot_fun","text":"Plot MTR MTE estimated curves confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots — mtr_plot_fun","text":"","code":"mtr_plot_fun(dat_plot, common_supp)  mte_plot_fun(dat_plot, common_supp)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots — mtr_plot_fun","text":"dat_plot Data frame estimated MTE MTR values confidence intervals. Must contain specific variables: Phat, mtr0, mtr1, mtr0_lwr, mtr1_lwr, mtr0_upr, mtr1_upr, mte, mte_lwr, mte_upr. common_supp Vector two values indicating common support plot. Default full support 0,1. conf_band Indicates whether plot confidence intervals. Default \"TRUE\". colMTE, colD0, colD1 Color MTE, MTR0 MTR1 curves.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/mtr_plot_fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marginal Treatment Effect (MTE) and Responses (MTR) plots — mtr_plot_fun","text":"Attention: default semiivreg confidence intervals computed analytically, include error first stage propensity score. corrected semiivreg_boot bootstrapping entire estimation obtain confidence intervals.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Roy Data with Heterogenous Treatment Effects — roydata","title":"Generalized Roy Data with Heterogenous Treatment Effects — roydata","text":"data frame 100,000 observations drawn simulated Roy model heterogenous treatment effects using simul_data().","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Roy Data with Heterogenous Treatment Effects — roydata","text":"","code":"data(roydata)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Generalized Roy Data with Heterogenous Treatment Effects — roydata","text":"data contains following information observed standard dataset: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. also reports typically unobserved potential outcomes shocks: y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation. data generated using following R code:","code":"N=100000; set.seed(1234) model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.7, 0.7, 0, 0, 0) param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  roydata = simul_data(N, model_type, param_y0, param_y1,                      param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Roy Data with Homogenous Treatment Effects — roydata2","title":"Generalized Roy Data with Homogenous Treatment Effects — roydata2","text":"data frame 100,000 observations drawn simulated Roy model homogenous treatment effects using simul_data().","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Roy Data with Homogenous Treatment Effects — roydata2","text":"","code":"data(roydata2)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/roydata2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Generalized Roy Data with Homogenous Treatment Effects — roydata2","text":"data contains following information observed standard dataset: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. also reports typically unobserved potential outcomes shocks: y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation. data generated using following R code:","code":"N = 100000; set.seed(1234) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.5, 0.5, 0, 0, 0) param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  roydata2 = simul_data(N, model_type, param_y0, param_y1,                       param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-IV Regression Function — semiivreg","title":"Semi-IV Regression Function — semiivreg","text":"Semi-IV regression function Bruneel-Zupanc (2024). Syntax inspired ivreg. Returns MTE MTR curves confidence intervals. estimation almost instantaneous (seconds ). default, return analytic standard errors accounting fact propensity score estimated first stage semiivreg. Use semiivreg_boot obtain 'correct' bootstrapped confidence intervals (takes bit longer).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-IV Regression Function — semiivreg","text":"","code":"semiivreg(formula, data, propensity_formula=NULL, propensity_data = NULL,                  ref_indiv =NULL, firststage_model = \"probit\",                  est_method = \"locpoly\", # \"locpoly\", \"sieve\", or \"homogenous\".                  se_type = \"HC1\",                  bw0 = NULL, bw1 = NULL, bw_y0 = NULL, bw_y1 = NULL, bw_method = \"rule-of-thumb\",                  pol_degree_locpoly1 = 1, pol_degree_locpoly2 = 2,                  pol_degree_sieve = 5, conf_level = 0.05,                  common_supp_trim=c(0,1), trimming_value=NULL, automatic_trim=FALSE,                  plotting=TRUE, print_progress=FALSE)  semiivreg_boot(formula, Nboot=500, data, propensity_formula=NULL, ref_indiv =NULL,                firststage_model=\"probit\", est_method = \"locpoly\", se_type=\"HC1\",                bw0 = NULL, bw1 = NULL, bw_y0 = NULL, bw_y1 = NULL, bw_method = \"rule-of-thumb\",                pol_degree_locpoly1 = 1, pol_degree_locpoly2 = 2,                common_supp_trim=c(0,1), trimming_value = NULL,                automatic_trim = FALSE, plotting=TRUE, conf_level = 0.05, CI_method = \"curve\")  semiiv_predict(semiiv, newdata, seq_v=NULL)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-IV Regression Function — semiivreg","text":"formula Formula regression, form outcome ~ treatment | semi-iv0 | semi-iv1 | commoncovariates.  treatment variable binary (0, 1).  covariates effect differs D=1 D=0 included semi-iv0 semi-iv1.  est_method = \"locpoly\": restrict covariates common effects (implemented), commoncovariates just estimated generally different effect Y0 Y1. data Dataframe containing data. propensity_formula Formula 1st stage. nothing specified, just runs probit d ~ semi-iv0 + semi-iv1 + covariates (removing redundant variables). propensity_data Data used compute 1st stage; ignore default set NULL = data. Mainly useful internal bootstrap function first stage formula different default one. ref_indiv Specify reference individual (terms covariates) evaluate function.  default takes average value covariates (trimmed dataset) compute average estimate. Remark: factors, average computed dummy variables get proper average effect. firststage_model default, first stage probit model. Can specify another model (e.g., \"logit\"). est_method Estimation method: default \"locpoly\" Robinson (1988) double residual regression partially linear model. options include \"sieve\" specify flexibly control function polynomial pol_degree_sieve, \"homogenous\" sieve also impose homogenous treatment effect. se_type Type standard errors sieve/homogenous estimation. default = \"HC1\". Can otherwise possibilities vcovHC sandwich package. Also possible se_type=\"nonrobust\" non-robust (lm default). bw0, bw1 Bandwidth first residual regressions Wd X Phat.  Two possibilities: specify one value applied covariates, specify different bandwidth regression covariate. second case, need specified order covariates specified model. careful factors.  Default NULL computed using specified bw_method. bw_y0, bw_y1 Bandwidth second regression Y (net effects covariates) Phat. Default NULL computed using specified bw_method. bw_method Method compute bandwidth local polynomial regressions. Default simple \"rule--thumb\" method. Alternatives include \"cv\" cross-validation \"plug-\" plug-bw (Fan Gijbels, 1996).  Note \"cv\" \"plug-\" computed randomly drawn subsample 5000 observations. replicability, set seed running semiivreg. Plug-bandwidth computed degree odd. pol_degree_locpoly1 Degree local polynomial regression covariates Phat. Default 1 recommended Fan Gijbels (1996) want estimate regular function. pol_degree_locpoly2 Degree local polynomial regression Y (net effects covariates) Phat. Default 2 recommended Fan Gijbels (1996) want estimate derivative function. pol_degree_sieve Degree polynomial transformation control function. conf_level Confidence level confidence intervals. common_supp_trim Vector two values indicating set propensity scores evaluate function.  Default full support [0,1]. can trimmed manually. trimming_value Can either vector c(0.05, 0.95) indicating quantile propensity score keep observations D=0 D=1.  Can also single value, case symmetric trimming .  Inserting trimming_value generates automatic_trim = TRUE automatically. automatic_trim TRUE, estimation second stage done common_support . plotting TRUE wants plot end function, FALSE otherwise. print_progress TRUE wants print progress function, FALSE otherwise (default=FALSE). Nboot Number bootstrap samples. block_boot_var Variable base block bootstrap. default, = NULL standard bootstrap. CI_method \"delta\" delta method, \"curve\" bootstrap MTE curves directly. est_method = \"locpoly\", \"curve\" method possible. semiiv Object returns semiivreg estimation. newdata New data predict MTE MTR. seq_v Sequence v predict MTE MTR. default: NULL fits default interval original semiivreg (equally space grid proba, step size 0.001 common support).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-IV Regression Function — semiivreg","text":"list following elements: $data Returns data output estimation used plot MTE MTR. details: $RES Dataframe estimated MTE MTR values (confidence intervals est_method=\"sieve\" \"homogenous\") sequence unobservable resistance treatment identifiable common support. $data Original data used estimation added propensity score estimated, named Phat, made transformation eventual factor variables dummies. $ref_indiv Reference individual(s) evaluate MTE MTR. $Xdat Set covariates (output used bootstrap). $deltaX Returns estimated effects covariates semi-IVs (without intercept) specified reference individuals. $estimate Returns estimation : $est, $est0 $est1 est_method = \"locpoly\", est0 est1 returns second stage estimates effect covariates semi-IVs respective potential outcomes. Coming double residual regression à la Robinson (1988), running -intercept OLS residuals Y-E(Yd|P) residuals every semi-IVs, Wd-E(Wd|P), covariates, X-E(X|P). $mtr0, $mtr1 $mte est_method = \"sieve\" \"homogenous\", returns functional form estimated MTR MTE. $kv Returns estimated k_d(v) (=E(Ud|V=v)). Includes constant. sums effect covariates semi-IVs (deltadX), gives mtr_d. $propensity First stage estimate propensity score. $est_kappa est_method = \"sieve\" \"homogenous\", returns estimated model E(Y|D=d, X, Wd, P). , extract Kappad(P) = E(Ud | D=d, P=p) compute kd(v) mtrd(v, x, wd) functions. $avg_MTE Average MTE identified common support. full common support, estimate ATE(x, w0, w1). est_method=\"homogenous\", MTE constant also gives ATE(x, w0, w1). $bw Returns bandwidth used (estimated via bw_method) Robinson double residual regression. bw0 bw1 bandwidths first residual regressions Yd, Wd X Phat. bw_y0 bw_y1 bandwidths second regression Y (net effects covariates) Phat. one matters smoothness MTE MTR estimates. $plot Returns separately following plot objects: supp (support), mtr, mte. $supp Returns common support propensity score Phat two treatment group. $call Returns call function covariates semi-IVs used.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"the-estimated-model","dir":"Reference","previous_headings":"","what":"The estimated model","title":"Semi-IV Regression Function — semiivreg","text":"semiivreg estimates marginal treatment effect (MTE) marginal treatment response (MTR) binary treatment variable using semi-IVs, W0 W1. standard IVs (see Andresen, 2018), estimate semi-parametric partially linear model, described Bruneel-Zupanc (2024). details model estimation procedure, see vignette vignette(\"semiIVreg\", package = \"semiIVreg\"), also available online . details use semiivreg function, see also vignettes vignette(\"semiIVreg_heterogenousTE\", package = \"semiIVreg\") vignette(\"semiIVreg_homogenousTE\", package = \"semiIVreg\"). details causal inference semi-IVs general, see Bruneel-Zupanc (2024).","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"caution-about-the-estimated-standard-errors","dir":"Reference","previous_headings":"","what":"Caution about the Estimated Standard errors","title":"Semi-IV Regression Function — semiivreg","text":"default, est_method=\"locpoly\" returns standard errors.  est_method=\"sieve\" est_method=\"homogenous\", returns analytic standard errors: wrong account fact propensity score estimated.  case, recommend use semiivreg_boot obtain 'correct' bootstrapped confidence intervals. Implemented separately bootstrap takes time, baseline semiivreg function almost instantaneous.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Semi-IV Regression Function — semiivreg","text":"Bruneel-Zupanc, C. (2024). (fully) exclude , necessary! Identification semi-IVs. arXiv preprint arXiv:2303.12667. empirical applications estimation Marginal Treatment Effects standard IVs, see example:  Carneiro, P., Heckman, J. J., & Vytlacil, E. J. (2011). Estimating marginal returns education. American Economic Review, 101(6), 2754-2781. Brinch, C. N., Mogstad, M., & Wiswall, M. (2017). Beyond LATE discrete instrument. Journal Political Economy, 125(4), 985-1039. particular, see Andresen, M. E. (2018). Exploring marginal treatment effects: Flexible estimation using Stata. Stata Journal, 18(1), 118-158. double residual estimation partially Linear models, see Robinson, P. M. (1988). Root-N-consistent semiparametric regression. Econometrica: Journal Econometric Society, 931-954. local polynomial regressions choice degree: Fan, J., & Gijbels, . (1996). Local polynomial modelling applications.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Semi-IV Regression Function — semiivreg","text":"Christophe Bruneel-Zupanc, cbruneel.com","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/semiivreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-IV Regression Function — semiivreg","text":"","code":"# Load data: data(roydata)  # Run the semi-IV regression semiiv = semiivreg(y~d|w0|w1, data=roydata)  semiiv = semiivreg(y~d|w0|w1|Xbinary + Xcontinuous, data=roydata) # with covariates  semiiv = semiivreg(y~d|w0+Xbinary|w1+Xbinary|Xcontinuous, data=roydata)  # Xbinary has different effect on Y0 and Y1, Xcontinuous has the same. semiiv = semiivreg(y~d|w0|w1, data=roydata, propensity_formula = d~w0+w1+w0:w1)  # if want to specify another first stage  semiiv$plot$mtr # if want to plot mtr_plot"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"function simulates data Generalized Roy Model semi-IVs, following simulation specified Bruneel-Zupanc (2024).  details exact specification, see vignettes running vignette(\"simul_data\", package = \"semiIVreg\").","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"","code":"simul_data(N, model_type=\"heterogenous\",            param_y0, param_y1, param_p, param_Z, param_genX, param_error)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"N Number observations model_type Type model: \"heterogenous\" \"homogenous\" param_y0 Parameters Y0 = (delta0, beta0, beta0X1, beta0X2)  .e., intercept, effects w0, X_1, X_2 Y0. param_y1 Parameters Y1: (delta1, beta1, beta1X1, beta1X2).  .e., intercept, effects w1, X1, X2 Y1. param_p Parameters selection: (alpha, alpha0, alpha1, alpha2, alphaX1, alphaX2) .e., intercept effects w0, w1, w0w1, Xbinary, Xcontinuous latent utility. param_Z Parameters simulation semi-IVs:  mean W0 X1=0, W1 X1=0, W0 X1=1, W1 X1=1; variance W0, W1, covariance W0 W1. param_genX Parameters covariates: p_X1, mu_X2, sigma_X2. param_error Parameters error terms: depends model_type:  heterogenous: variance U0, U1, covariance U0 U1, variance cost (mean 0).  homogenous: variance U, variance V, covariance U V.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"data frame following columns: y observed outcome. d treatment. w0, w1 semi-IVs entering D=0 D=1. Xbinary, Xcontinuous Two covariates, one binary one continuous. y0, y1 unobserved potential outcomes. P unobserved true treatment probability. latent, V, Ud, U0, U1 unobserved shocks V. Ud normalized V ranks. U0 U1 outcome shocks. latent gives latent utility term selection equation.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"function simulates data Generalized Roy Model semi-IVs, following simulation specified Bruneel-Zupanc (2024).  details exact specification, see vignette running vignette(\"simul_data\", package = \"semiIVreg\"). One can use simulate general model heterogenous treatment effects, also restricted ones homogenous treatment effects. simul_data used simulate dataset available package, data(roydata) obtain simulated model heterogenous treatment effect, data(roydata2) obtain simulated model homogenous treatment effect.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"Bruneel-Zupanc, C. (2023). (fully) exclude , necessary! Identification semi-IVs. arXiv preprint arXiv:2303.12667. Andresen, M. E. (2018). Exploring marginal treatment effects: Flexible estimation using Stata. Stata Journal, 18(1), 118-158. Heckman, J. J., Urzua, S., & Vytlacil, E. (2006). Understanding instrumental variables models essential heterogeneity. Review Economics Statistics, 88(3), 389-432. Heckman, J. J., & Vytlacil, E. J. (2007). Econometric evaluation social programs, part II: Using marginal treatment effect organize alternative econometric estimators evaluate social programs, forecast effects new environments. Handbook econometrics, 6, 4875-5143.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/simul_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate data from the Generalized Roy Model with semi-IVs — simul_data","text":"","code":"N = 10000; set.seed(12345)  # Example 1: Heterogenous Treatment Effects. model_type = \"heterogenous\" param_error = c(1, 1, 0.6, 0.5) # var_u0, var_u1, cov_u0u1, var_cost param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) # meanW0 Xbinary0, meanW1 Xbinary0, meanW0 Xbinary1, meanW1 Xbinary1, varW0, varW1, covW0W1 param_p = c(0, -0.7, 0.7, 0, 0, 0) # constant, W0, W1, W0xW1, Xbinary, Xcontinuous param_y0 = c(3.2, 0.8, 0, 0) # intercept, W0, Xbinary, Xcontinuous; param_y1 = c(3.2+0.4, 0.5, 0, 0) # the +0.4 = ATE; W1, Xbinary, Xcontinuous; param_genX = c(0.4, 0, 2)  data = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)   # Example 2: Homogenous Treatment Effects (constant MTE) model_type = \"homogenous\" param_error = c(1, 1.5, -0.6) # var_u, var_v, cov_uv param_Z = c(0, 0, 0, 0, 1.5, 1.5, 0.9) param_p = c(0, -0.5, 0.5, 0, 0, 0) # the constant <=> mean_V param_y0 = c(3.2, 0.8, 0, 0) param_y1 = c(3.2+0.4, 0.5, 0, 0) param_genX = c(0.4, 0, 2)  data1 = simul_data(N, model_type, param_y0, param_y1, param_p, param_Z, param_genX, param_error)   # Set the effects of w1 or w0 on its outcome to zero if want a valid IV, e.g., # param_y1 = c(3.2+0.4, 0, 0, 0) # w1 is a valid IV # or: param_y0 = c(3.2, 0, 0, 0) # w0 is a valid IV"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Propensity score support plot — supp_plot_fun","title":"Propensity score support plot — supp_plot_fun","text":"Returns support plot treatment status propensity score Phat included dataset.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propensity score support plot — supp_plot_fun","text":"","code":"supp_plot_fun(data, common_supp)"},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Propensity score support plot — supp_plot_fun","text":"data Dataframe containing treatment status, factor variable Treatment propensity score name Phat. common_supp Vector two values indicating common support plot. Default full support 0,1. colMTE, colD0, colD1 Color MTE, MTR0 MTR1 curves.","code":""},{"path":"https://cbruneelzupanc.github.io/semiIVreg/reference/supp_plot_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Propensity score support plot — supp_plot_fun","text":"","code":"# Plot the true common support (with true - unobserved - propensity score) # Using simulated data. data(roydata); data=roydata;  # Syntax adjustment to use the function data$Treatment = factor(data$d) data$Phat = data$P # P is unobserved, we only know it because simulation here  #common_supp can be determined by looking at the plot - it's not necessary, just a graphical option supp_P0 = c(min(data$Phat[which(data$d == 0)]), max(data$Phat[which(data$d== 0)])) supp_P1 = c(min(data$Phat[which(data$d == 1)]), max(data$Phat[which(data$d == 1)])) common_supp = c(max(supp_P0[1], supp_P1[1]), min(supp_P0[2], supp_P1[2]))  supp_plot = supp_plot_fun(data, common_supp); supp_plot"}]
